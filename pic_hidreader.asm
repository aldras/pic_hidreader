;==========================================================================================================================
;	W7YH HID 26-BIT WIEGAND FORMAT DOOR CONTROLLER
;
;	REVISION 1.0c
;	REVISED 2011-06-18
;	ADDED THE FEATURE TO PRINT OUT THE NAME ASSOCIATED WITH THE SCANNED CARD
;	ALSO THIS WORKS WHEN DOING MANUAL SEARCHES
;
;	REVISION 1.0b
;	REVISED 2011-05-21
;	CHANGED TO RUN ON A PIC16F88 DIP18 PACKAGED CHIP
;
;	REVISION 1.0a
;	REVISED 2011-05-08
;	CHANGED THE WAY STRING TABLES ARE READ AND OUTPUT TO SAVE PROGRAM MEMORY SPACE
;	SWITCHED THE ORDER OF THE OUTPUT WHEN A SUCCESSFUL CARD IS READ FROM "000-00000 PASS/FAIL"
;		TO THE FORMAT "PASS/FAIL 000-00000" TO MAKE IT EASIER TO PARSE WHEN NAME AND OTHER
;		INFORMATION IS ADDED TO THAT OUTPUT, IN THE NEAR FUTURE
;	ADDED COMMANDS TO READ MEMORY AND ERASE MEMORY
;
;	VERSION 1.0 INITIAL REVISION
;	REVISED 2011-01-21
;
;	PROGRAM PURPOSE
;	CONTROL ACCESS TO A DOOR THAT USES AN HID 26-BIT WIEGAND FORMAT PROXIMITY CARD READER
;	AFTER THE CARD IS READ, THE MICROCONTROLLER WILL DETERMINE IF THE CARD HAS ACCESS TO
;	THE DOOR OR NOT BY COMPARING THE READ CARD NUMBER TO THOSE STORED IN A EEPROM MEMORY CHIP
;	IF THE CARD NUMBER MATCHES ONE FOUND IN MEMORY, TURN ON A RELAY FOR A FEW SECONDS TO ALLOW
;	ENTRY, THEN TURN THE RELAY BACK OFF
;
;	DEVICE USED
;	MICROCHIP PIC16F77 IS USED AS THE MICROCONTROLLER WITH AN EXTERNAL 4Mhz CRYASTAL
;	HOWEVER, THE PROGRAM WAS WRITTEN AND EMULATED AS A PIC16C67 WHICH IS ALMOST IDENTICAL
;	TO THE PIC16F77 EXCEPT FOR THE A/D CONVERTERS AND A FEW OTHER MINOR DIFFERENCES
;	SO, THIS EXPLAINS THE ADDITION OF SOME LINES OF CODE THAT ARE CURRENTLY COMMENTED OUT
;
;	DATA IN THE EEPROM MEMORY IS LAYED OUT AS FOLLOWS
;	A MICROCHIP 24LC64 (64K BIT, 8K BYTE IIC INTERFACED) MEMORY CHIP IS EXPECTED
;	THE CHIP, WHEN IT COMES FROM THE FACTORY, IS PROGRAMMED ALL BYTES "FF"
;
;	THE MEMORY CHIP IS DIVIDED INTO 32 BYTE PAGES, THERE ARE 256 OF THESE PAGES AVAILABLE
;	WE WILL USE ONE MEMORY PAGE PER STORED ACCESS CARD
;	HOWEVER, THE FIRST MEMORY PAGE (0000 TO 001F) IS THE FAT (FILE ALLOCATION TABLE) WHICH WILL KEEP
;	TRACK OF WHICH MEMORY PAGES HAVE STORED DATA, AND WHICH ONES ARE CONSIDERED ERASED (FREE TO REWRITE)
;
;	WHEN A CARD IS DELETED FROM THE MEMORY, THE DATA IS NOT ACTUALLY ERASED, BUT JUST MARKED FREE IN THE FAT
;
;	MEMORY LAYOUT
;	0000 TO 001F	FAT
;	0020 TO 003F	CARD 001 INFORMATION
;	0040 TO 005F	CARD 002 INFORMATION
;	0060 TO 007F	CARD 003 INFORMATION
;	0080 TO 009F	CARD 004 INFORMATION
;	00A0 TO 00BF	CARD 005 INFORMATION
;	00C0 TO 00DF	CARD 006 INFORMATION
;	00E0 TO 00FF	CARD 007 INFORMATION
;		:		:
;		:		:
;	1FE0 TO 1FFF	CARD 255 INFORMATION
;
;
;	BREAKDOWN OF INFORMATION STORED IN EACH 32 BYTE PAGE
;	0020 TO 0020	CARD STATUS BYTE (BYTE 7 IS ADMIN, BYTE 0 IS ENABLED, OTHER BITS ARE DON'T CARE)
;	0021 TO 0021	SITE CODE (ONE BYTE)
;	0022 TO 0023	CARD NUMBER (TWO BYTES)
;	0024 TO 003F	STRING DATA (MOST LIKELY USER NAME) WILL TAKE ASCII CHARACTERS, END OF STRING H'00'
;
;	USING A PIC16F77 40DIP PACKAGE RUNNING AT 4Mhz CLOCK
;	MICROCONTROLLER PHYSICAL CONNECTION SUMMARY
;	PORT A
;		BIT 0	WIEGAND DATA 0 LINE
;		BIT 1	WIEGAND DATA 1 LINE
;		BIT 2	WIEGAND RED LED
;		BIT 3	WIEGAND GREEN LED
;		BIT 4	WIEGAND BUZZER
;	PORT B
;		BIT 0	EXTERNAL INTERRUPT
;		BIT 1	IIC SDA
;		BIT 2	RS232 RX
;		BIT 3	UNIMPLEMENTED
;		BIT 4	IIC SCL
;		BIT 5	RS232 TX
;		BIT 6	RELAY OUTPUT FOR UNLOCKING DOOR
;		BIT 7	UNIMPLEMENTED
;
;	USING A PIC16F88 18DIP PACKAGE RUNNING AT 4Mhz CLOCK
;	CONNECTIONS TO THE MICROCONTROLLER IS AS FOLLOWS
;	PIN	FUNCTION	CONNECTION			DESCRIPTION
;	1	RA2/AN2		GND				WIEGAND GREEN LED
;	2	RA3/AN3		GND				WIEGAND RED LED
;	3	RA4/AN4		GND				WIEGAND BUZZER
;	4	RA5/MCLR	1K TO +5, 0.01uF TO GND		RESET
;	5	VSS		GND				POWER IN GND
;	6	RB0/INT		EXTERNAL INTERRUPT CONNECTED THROUGH DIOIDES TO PORTA BITS 0 AND 1
;	7	RB1/SDA/SDI	IIC SDA			MEMORY CHIP DATA LINE
;	8	RB2/SDO/RX	RS232 TX		RS232 RXIN
;	9	RB3/PGM		GND				UNIMPLEMENTED
;	10	RB4/SCK/SCL	IIC SCL			MEMORY CHIP CLOCK LINE
;	11	RB5/TX		RS232 RX		RS232 TXOUT
;	12	RB6/AN5		RELAY			CONNECTION FOR DOOR RELAY
;	13	RB7/AN6		GND				UNIMPLEMENTED
;	14	VDD		+5				POWER IN +5
;	15	RA6/OSC2	4Mhz CRYSTAL			XT CRYSTAL CONNECTION
;	16	RA5/OSC1	4Mhz CRYSTAL			XT CRYSTAL CONNECTION
;	17	RA0/AN0		WIEGAND DATA 0 LINE
;	18	RA1\AN1		WIEGAND DATA 1 LINE
;
;
;	STATUS_STATE (KEEPS TRACK OF THE STATE THAT WE ARE IN, WHAT MENU SELECTION WE ARE IN NOW):
;	H'00'		NOTHING HAPPENING WITH RS232, NORMAL STATE, ROOT MENU
;	H'10'		IN CARD ADD MODE, WAITING FOR SITEID
;	H'11'		IN CARD ADD MODE, WAITING FOR CARDID
;	H'12'		IN CARD ADD MODE, WAITING FOR STRING (NAME)
;	H'30'		IN CARD SEARCH MODE, WAITING FOR SITEID
;	H'31'		IN CARD SEARCH MODE, WAITING FOR CARDID
;	H'40'		IN CARD DELETE MODE, WAITING FOR FILEID TO DELETE
;	H'50'		IN MEMORY READ MODE, WAITING FOR START ADDRESS
;	H'51'		IN MEMORY READ MODE, WAITING FOR STOP ADDRESS

;	REGARDLESS WHAT STATE WE ARE IN, PRESSING THE ENTER KEY WITH NO DATA IN THE RXIN BUFFER
;	WILL RESET THE STATE BACK TO H'00' AND CANCEL ANY STATE WE ARE PRESENTLY IN
;	STATE H'020' WAS INTENDED TO BE USED FOR A CARD EDIT MODE, BUT HAS NOT BEEN IMPLEMENTED, YET
;
;	RS232 COMMAND SUMMARY
;	'a'  = ADD CARD
;	'b'  = ADD LAST SCANNED CARD
;	'd'  = DELETE CARD
;	'lc' = LIST CARDS BY CARDID (NOT IMPLEMENTED)
;	'lf' = LIST CARDS BY FILE NUMBER
;	'ln' = LIST CARDS BY NAME (NOT IMPLEMENTED)
;	'mr'  = ERASE FAT TABLE (CLEARS ALL CARDS FROM THE SYSTEM) (DISABLED)
;	's'  = SEARCH FOR CARD BY SITEID AND CARDID
;	'v'  = VERSION INFORMATION
;	'?'  = HELP MENU


;==========================================================================================================================
;	WHEN EMULATING USING PIC16C67 HARDWARE, BE SURE TO CHANGE THE FOLLOWING LINES TO REFLECT THAT
;		LIST P=16C67
		LIST P=16F88
                ERRORLEVEL  -302
;	include <p16C67.inc>
	include <p16F88.inc>

;	CONFIGURATION BITS, CODE PROTECT OFF, WATCH DOG TIMER OFF, EXTERNAL CRYSTAL, BROWNOUT DETECT ON, POWER ON TIMER ON
;	ENABLE ONLY ONE OF THE FOLLOWING TWO LINES DEPENDING ON WHAT MICROCONTROLLER IS BEING USED

;	NEXT LINE IS FOR PIC16F77 OR PIC16C67
;  __CONFIG _CP_OFF & _WDT_OFF & _XT_OSC & _BODEN_ON & _PWRTE_ON

;FIX TO ALLOW BACKWARDS COMPATIBILITY WITH NEWER TMR0IF DEFINITION
;UNCOMMENT WHEN USING A PIC16C67
;TMR0IF		EQU	T0IF
;TMR0IE		EQU	T0IE

;	NEXT TWO LINES ARE FOR PIC16F88
	__CONFIG	_CONFIG1, _XT_OSC & _CP_OFF & _CCP1_RB0 & _DEBUG_OFF & _WRT_PROTECT_OFF & _CPD_OFF & _LVP_ON & _BODEN_ON & _MCLR_ON & _PWRTE_ON & _WDT_OFF
	__CONFIG	_CONFIG2, _IESO_OFF & _FCMEN_OFF
;==========================================================================================================================
;       SPECIFY NAMES TO REGISTERS
;==========================================================================================================================
;IIC USE FOR BIT COMMUNICATIONS
ERR_1			EQU	0		; Error flag
DI			EQU	7		; EEPROM input
DO			EQU	6		; EEPROM output

;IIC PHYSICAL PORT CONNECTIONS FOR PIC16C67
;PORT_IIC		EQU	PORTC
;TRIS_IIC		EQU	TRISC
;SDA			EQU	4
;SCL			EQU	3

;IIC PHYSICAL PORT CONNECTIONS FOR PIC16F88
PORT_IIC		EQU	PORTB
TRIS_IIC		EQU	TRISB
SDA			EQU	1
SCL			EQU	4

;WIEGAND INTERFACE PHYSICAL PORT CONNECTIONS
PORT_WIEGAND		EQU	PORTA		;WIEGAND DATA PORT
TRIS_WIEGAND		EQU	TRISA
WG_D0			EQU	0		;WIEGAND DATA 0 LINE
WG_D1			EQU	1		;WIEGAND DATA 1 LINE
WG_LED_GREEN	EQU	2		;WIEGAND GREEN LED
WG_LED_RED		EQU	3		;WIEGAND RED LED
WG_BUZZER		EQU	4		;WIEGAND BUZZER
WIEGAND_INT		EQU	PORTB		;WIEGAND INTERRUPT PORT
WG_INT			EQU	0		;WIEGAND INTERRUPT LINE

;RELAY OUTPUT PHYSICAL PORT CONNECTIONS
PORT_RELAY		EQU	PORTB		;RELAY CONTROL
TRIS_RELAY		EQU	TRISB
RELAY_0			EQU	6		;RELAY 0

;RS232 OUTPUT PHYSICAL PORT CONNECTIONS
PORT_RS232		EQU	PORTB
TRIS_RS232		EQU	PORTB
RS232_RX		EQU	2
RS232_TX		EQU	5


WG_PARITY_E		EQU	1		;WIEGAND STATUS BIT 1 (EVEN PARITY BIT)
WG_PARITY_O		EQU	2		;WIEGAND STATUS BIT 2 (ODD PARITY BIT)


;RS232 BUFFERS
;WE HAVE 32 BYTES AS A RECEIVE BUFFER FOR THE RS232, SO COMMANDS CAN BE ENTERED
;AND THEN EXECUTED USING THE ENTER KEY
RXIN_00				EQU	H'20'		;RS232 RXIN BUFFER 00
RXIN_01				EQU	H'21'		;RS232 RXIN BUFFER 01
RXIN_02				EQU	H'22'		;RS232 RXIN BUFFER 02
RXIN_03				EQU	H'23'
RXIN_04				EQU	H'24'
RXIN_05				EQU	H'25'
RXIN_06				EQU	H'26'
RXIN_07				EQU	H'27'
RXIN_08				EQU	H'28'
RXIN_09				EQU	H'29'
RXIN_0A				EQU	H'2A'
RXIN_0B				EQU	H'2B'
RXIN_0C				EQU	H'2C'
RXIN_0D				EQU	H'2D'
RXIN_0E				EQU	H'2E'
RXIN_0F				EQU	H'2F'
RXIN_10				EQU	H'30'
RXIN_11				EQU	H'31'
RXIN_12				EQU	H'32'
RXIN_13				EQU	H'33'
RXIN_14				EQU	H'34'
RXIN_15				EQU	H'35'
RXIN_16				EQU	H'36'
RXIN_17				EQU	H'37'
RXIN_18				EQU	H'38'
RXIN_19				EQU	H'39'
RXIN_1A				EQU	H'3A'
RXIN_1B				EQU	H'3B'
RXIN_1C				EQU	H'3C'
RXIN_1D				EQU	H'3D'
RXIN_1E				EQU	H'3E'
RXIN_1F				EQU	H'3F'
RXIN_POSITION			EQU	H'40'		;POSITION WE ARE AT IN THE BUFFER

;RS232 VARIABLES
RXIN				EQU	H'41'		;RS232 RECEIVE BUFFER

;SYSTEM VARIABLES
TEMP_WREG			EQU	H'42'
TEMP_STATUS			EQU	H'43'
TEMP_PCLATH			EQU	H'44'
TEMP				EQU	H'45'
TABLE_OFFSET_L			EQU	H'46'		;TRACKS WHAT LOCATION WE ARE IN A LOOKUP TABLE
TABLE_OFFSET_H			EQU	H'47'		;TRACKS WHAT LOCATION WE ARE IN A LOOKUP TABLE
SYSTEM_STATE			EQU	H'48'		;THE CURRENT STATE OF THE MENU SYSTEM, WHAT MENU PROMPT ARE WE IN

;CARD VARIABLES
CARD_STATUS			EQU	H'49'		;STATUS BYTE FOR THE RETURNED OR SCANNED CARD
CARD_FILEID			EQU	H'4A'		;FILEID FOR THE RECENTLY SEARCHED CARD
CARD_SITEID			EQU	H'4B'
CARD_CARDID_HIGH		EQU	H'4C'		;CARDIDs CONSIST OF TWO BYTES, FOUR HEX DIGITS
CARD_CARDID_LOW			EQU	H'4D'
CARD_SITEID_SCANNED		EQU	H'4E'		;CARD INFORMATION FOR THE LAST SCANNED CARD BY THE READER
CARD_CARDID_LOW_SCANNED		EQU	H'4F'
CARD_CARDID_HIGH_SCANNED	EQU	H'50'
CARD_SITEID_SEARCH		EQU	H'51'		;CARD INFORMATION FOR THE CARD WE WANT TO SEARCH FOR IN THE
CARD_CARDID_LOW_SEARCH		EQU	H'52'		;SEARCH ROUTINE
CARD_CARDID_HIGH_SEARCH		EQU	H'53'
CARD_SITEID_KEYED		EQU	H'54'
CARD_CARDID_HIGH_KEYED		EQU	H'55'		;CARDIDs CONSIST OF TWO BYTES, FOUR HEX DIGITS
CARD_CARDID_LOW_KEYED		EQU	H'56'

;IIC VARIABLES
CHIP_OPEN			EQU	H'57'		;TRACKS WHETHER OR NOT THE EEPROM MEMORY CHIP IS OPEN FOR READING
TXBUF				EQU	H'58'		;TRANSMIT BUFFER FOR MEMOR WRITES
ADDR_H				EQU	H'59'		;HIGH ADDRESS BYTE FOR EEPROM MEMORY CHIP
ADDR_L				EQU	H'5A'		;LOW ADDRESS BYTE FOR EEPROM MEMORY CHIP
SEND_ACK			EQU	H'5B'
DATAO				EQU	H'5C'
DATAI				EQU	H'5D'
EEPROM				EQU	H'5E'
COUNT				EQU	H'5F'
DEL				EQU	H'60'
SEL				EQU	H'61'
RDBYTE_COUNTER			EQU	H'62'		;TRACKS THE NUMBER OF BYTES READ FROM THE EEPROM FOR CRLF PRETTY OUTPUT

TEMP_LOW			EQU	H'63'		;TEMP VARIBLES FOR WHEN WE CONVERT HEX (BASE 16) TO DECIMAL (BASE 10)
TEMP_HIGH			EQU	H'64'		;WE NEED TO BE ABLE TO SUPPORT A 16 BIT NUMBER
TEMP_LOW_WORKING		EQU	H'65'
TEMP_HIGH_WORKING		EQU	H'66'
TEMP_HEX_LOW			EQU	H'67'
TEMP_HEX_HIGH			EQU	H'68'

FAT_POINTER			EQU	H'69'		;FOR WORKING WITH THE DATA STORED IN THE EEPROM MEMORY CHIP
FAT_DATA			EQU	H'6A'		;DATA RETRIEVED FROM THE FAT
PAGE_POINTER			EQU	H'6B'		;ADDRESS POINTER FOR WHAT MEMORY PAGE WE ARE CURRENTLY ON
FREE_MEMORY_COUNTER		EQU	H'6C'		;COUNTER TO COUNT HOW MUCH FREE SPACE IS LEFT IN MEMORY

;WIEGAND VARIABLES
WG_DATA_STATUS			EQU	H'6D'		;WIEGAND STATUS REGISTER
WG_DATA_TEMP			EQU	H'6E'		;WIEGAND STATUS REGISTER
WG_DATA_COUNTER			EQU	H'6F'		;WIEGAND DATA COUNTER (TO TRACK WHAT BIT WE ARE ON)
WG_DATA_00			EQU	H'70'		;WIEGAND BYTE 0 (FACULTY CODE)
WG_DATA_01			EQU	H'71'		;WIEGAND BYTE 1 (FIRST CARD NUMBER BYTE)
WG_DATA_02			EQU	H'72'		;WIEGAND BYTE 2 (SECOND CARD NUMBER BYTE)

;TIMER 1 VARIABLES
BRES_LO				EQU	H'73'

;TEXT TABLE VARIABLES
TEXT_TABLE_H			EQU	H'74'
TEXT_TABLE_L			EQU	H'75'

MEM_READ_START_H		EQU	H'76'
MEM_READ_START_L		EQU	H'77'
MEM_READ_END_H			EQU	H'78'
MEM_READ_END_L			EQU	H'79'

	ORG		H'00'		;RESET VECTOR
	GOTO		START
;==========================================================================================================================
;	INTERRUPT VECTOR USED FOR GRABBING WIEGAND DATA
;==========================================================================================================================
	ORG		H'04'		;INTERRUPT VECTOR

		;SAVE STATE
		MOVWF		TEMP_WREG	;Copy W to TEMP register
		SWAPF		STATUS,W	;Swap status to be saved into W
		CLRF		STATUS		;bank 0, regardless of current bank, Clears IRP,RP1,RP0
		MOVWF		TEMP_STATUS	;Save status to bank zero STATUS_TEMP register
		MOVF		PCLATH, W	;Only required if using pages 1, 2 and/or 3
		MOVWF		TEMP_PCLATH	;Save PCLATH into W
		CLRF		PCLATH		;Page zero, regardless of current page

		;EXECUTE REQUIRED CODE
INT_NEXT	BTFSC		INTCON,INTF	;CHECK PORTB EXTERNAL INTERRUPT FLAG
		CALL		WIEGAND_GET	;GET DATA FROM THE DEVICE, ONE BIT AT A TIME
		BTFSC		PIR1,RCIF	;CHECK FOR RS232 RECEPTION FLAG INTERRUPT
		CALL		RS232_GET	;GET DATA FROM THE SERIAL PORT
		BTFSC		PIR1, TMR1IF	;CHECK FOR TIMER1 INTERRUPT FLAG
		CALL		T1_OVRFL	;RESET THE BUFFER BECAUSE THERE WAS A RECIEVED DATA ERROR
		BTFSC		INTCON,TMR0IF	;CHECK TIMER0 OVERFLOW INTERRUPT FLAG
		CALL		T0_OVRFL	;GET DATA FROM THE DEVICE, ONE BIT AT A TIME

		;RECALL STATE
		MOVF		TEMP_PCLATH, W	;Restore PCLATH
		MOVWF		PCLATH		;Move W into PCLATH
		SWAPF		TEMP_STATUS,W	;Swap STATUS_TEMP register into W
						;(sets bank to original state)
		MOVWF		STATUS		;Move W into STATUS register
		SWAPF		TEMP_WREG,F	;Swap W_TEMP
		SWAPF		TEMP_WREG,W	;Swap W_TEMP into W

		RETFIE				;RETURN FROM INTERRUPT

;==========================================================================================================================
;	PROGRAM START
;==========================================================================================================================
START
			BCF 		STATUS,RP1			;SPECIFY BANK 0
			BCF	 	STATUS,RP0

;==========================================================================================================================
;	PORT INITIALIZATION
;==========================================================================================================================
			CLRF		PORTA
			CLRF		PORTB
;			CLRF		PORTC
;			CLRF		PORTD
;			CLRF		PORTE

;==========================================================================================================================
;	REGISTER INITIALIZTION
;==========================================================================================================================
			CLRF		RXIN
;			CLRF		TXOUT
			CLRF		SYSTEM_STATE
			CLRF		CHIP_OPEN
			CLRF		WG_DATA_STATUS
			CLRF		WG_DATA_COUNTER
			CLRF		WG_DATA_00
			CLRF		WG_DATA_01
			CLRF		WG_DATA_02
			CLRF		TEMP
			CLRF		CARD_SITEID
			CLRF		CARD_CARDID_HIGH
			CLRF		CARD_CARDID_LOW
			CLRF		CARD_SITEID_SEARCH
			CLRF		CARD_CARDID_HIGH_SEARCH
			CLRF		CARD_CARDID_LOW_SEARCH
			CLRF		CARD_SITEID_SCANNED
			CLRF		CARD_CARDID_HIGH_SCANNED
			CLRF		CARD_CARDID_LOW_SCANNED
;==========================================================================================================================
;	AD SETUP - DISABLE ALL (COMMENT OUT) FOR PIC16C774
;==========================================================================================================================
			BCF		ADCON0,ADON		;DISABLE A/D
			BSF		STATUS,RP0		;BANK 1
			MOVLW		B'00001111'		;DISABLE A/D FUNCTIONS, CONFIGURE ALL PINS DIGITAL (NO ANALOG INPUTS)
			MOVWF		ADCON1
			CLRF		ANSEL		;ENABLE DIGITAL I/O ON ALL AD PINS
;==========================================================================================================================
;	SET I/O STATUS ON PORTS
;	1 = INPUT BIT
;	0 = OUTPUT BIT
;==========================================================================================================================
			MOVLW		B'11111111'			;SET ALL I/O FOR INPUT FIRST
			MOVWF		TRISA
			MOVWF		TRISB
;		UNCOMMENT NEXT THREE LINES IF USING PIC16C67 OR PIC16F77
;			MOVWF		TRISC
;			MOVWF		TRISD
;			MOVWF		TRISE
			BSF			TRIS_WIEGAND,WG_D0	;INPUT WIEGAND DATA 0 LINE
			BSF			TRIS_WIEGAND,WG_D1	;INPUT WIEGAND DATA 1 LINE
			BCF			TRIS_WIEGAND,WG_LED_RED	;OUTPUT WIEGAND RED LED
			BCF			TRIS_WIEGAND,WG_LED_GREEN	;OUTPUT WIEGAND GREEN LED
			BCF			TRIS_WIEGAND,WG_BUZZER	;OUTPUT WIEGAND BUZZER
			BSF			TRIS_IIC,SDA		;INPUT IIC MEMORY CLOCK LINE
			BSF			TRIS_IIC,SCL		;INPUT IIC MEMORY DATA LINE
			BCF			TRIS_RELAY,RELAY_0	;OUTPUT RELAY 0 (TO UNLOCK DOOR)
			BSF			TRIS_RS232,RS232_RX	;RS232 RX
			BSF			TRIS_RS232,RS232_TX	;RS232 TX

;			MOVLW		B'11100011'		;SET I/O STATUS ON PORTA
;					  ||||||||_______________WIEGAND DATA 0 INPUT
;					  |||||||________________WIEGAND DATA 1 INPUT
;					  ||||||_________________WIEGAND RED LED
;					  |||||__________________WIEGAND GREEN LED
;					  ||||___________________WIEGAND BUZZER
;					  |||____________________N/C
;					  ||_____________________N/C
;					  |______________________N/C
;			MOVWF		TRISA
;			MOVLW		B'10111111'		;SET I/O STATUS ON PORTB
;					  ||||||||_______________EXTERNAL INTERRUPT, CONNECTED THROUGH DIODES TO WIEGAND DATA LINES
;					  |||||||________________IIC SDA
;					  ||||||_________________RS232 RX - TO MAX232 LEVEL CONVERTER
;					  |||||__________________N/C
;					  ||||___________________IIC SCL
;					  |||____________________RS232 TX - TO MAX232 LEVEL CONVERTER
;					  ||_____________________DOOR LATCH RELAY
;					  |______________________N/C
;			MOVWF		TRISB
;			MOVLW		B'11100111'		;SET I/O STATUS ON PORTC
;					  ||||||||_______________N/C
;					  |||||||________________N/C
;					  ||||||_________________N/C
;					  |||||__________________IIC SCK - TO EEPROM MEMORY CHIP
;					  ||||___________________IIC SDA - TO EEPROM MEMORY CHIP
;					  |||____________________N/C
;					  ||_____________________
;					  |______________________
;			MOVWF		TRISC
;			MOVLW		B'11111111'		;SET I/O STATUS ON PORTD
;					  ||||||||_______________N/C
;					  |||||||________________N/C
;					  ||||||_________________N/C
;					  |||||__________________N/C
;					  ||||___________________N/C
;					  |||____________________N/C
;					  ||_____________________N/C
;					  |______________________N/C
;			CLRF		TRISD			;SET ALL OUTPUTS ON PORT D, WE DON'T USE ANY
;			CLRF		TRISE			;SET ALL OUTPUTS ON PORT E, WE DON'T USE ANY
;==========================================================================================================================
;	WIEGAND READER STATUS INDICTAORS INITIALIZATION
;==========================================================================================================================
			BCF		STATUS,RP0		;BANK 0
			BSF		PORT_WIEGAND,WG_LED_RED			;TURN RED LED OFF
			BSF		PORT_WIEGAND,WG_LED_GREEN			;TURN GREEN LED OFF
			BSF		PORT_WIEGAND,WG_BUZZER			;TURN BUZZER OFF
			BCF		PORT_RELAY,RELAY_0				;TURN OFF RELAY
;==========================================================================================================================
;	IIC INITIALIZATION
;==========================================================================================================================
			BCF		SSPCON,SSPEN	;DISABLE SSP (WE WILL MANUALLY MAKE OUR OWN IIC ROUTINES)
;==========================================================================================================================
;	RS232 INITIALIZATION
;==========================================================================================================================
			BSF		STATUS,RP0		;BANK 1
			MOVLW		B'00011001'		;9615 BAUD RATE FOR 4MHz
;			MOVLW		B'01000000'		;9615 BAUD RATE FOR 10MHz
;			MOVLW		B'01100111'		;2403 BAUD RATE FOR 4MHz
			MOVWF		SPBRG
			BSF		TXSTA,2			;SET BRGH
			BCF		TXSTA,4			;CLEAR BIT SYNC
			BCF		TXSTA,6			;CLEAR BIT TX9
			BCF		STATUS,RP0		;BANK 0
			BSF		RCSTA,7			;SET BIT SPEN
			BCF		RCSTA,6			;CLEAR BIT RX9
			BSF		RCSTA,4			;SET BIT CREN
			BCF		PIR1,3
			BSF		RCSTA,4			;ENABLE RECEPTOPN BIT CREN
			BSF		TXSTA,5			;SET BIT TXEN
			MOVLW		H'20'			;SET THE INITIAL BUFFER POSITION
			MOVWF		RXIN_POSITION		;PUT THE CONTENTS IN THE INDIRECT FILE REGISTER
;==========================================================================================================================
;	INTERRUPT INITIALIZATION
;==========================================================================================================================
			BCF		STATUS,RP0			;BANK 0
			CLRF		PIR1				;CLEAR INTERRUPT FLAGS
			CLRF		PIR2				;CLEAR INTERRUPT FLAGS
			BSF		STATUS,RP0			;BANK 1
			CLRF		INTCON				;CLEAR INTERRUPT FLAGS AND ENABLES
			BCF		OPTION_REG,INTEDG		;INTERRUPT ON FALLING EDGE ON EXTERNAL INTERRUPT
			BCF		OPTION_REG,PSA			;PRESCALER ASSIGNED TO WDT, NOT TO TIMER0
			BSF		INTCON,INTE			;EXTERNAL INTERRUPT ON PORTB,0 ENABLE
			BSF		PIE1,RCIE			;RS232 RECEPTION INTERRUPT ENABLE
			BSF		INTCON,PEIE			;PERIPHERAL INTERRPUT ENABLE
			BSF		INTCON,TMR0IE			;ENABLE TIMER0 INTERRUPT ON OVERFLOW
			BSF 		INTCON,GIE 			;GLOBAL INTERRUPT ENABLE
;==========================================================================================================================
;	TIMER0 INITIALIZATION INCLUDING INTERRUPT ENABLE
;==========================================================================================================================
	BCF				OPTION_REG,T0CS
;==========================================================================================================================
;	TIMER1 INITIALIZATION INCLUDING INTERRUPT ENABLE
;==========================================================================================================================
			BCF		STATUS,RP0		;BANK0
			MOVLW		B'00110100'		;SET TIMER1 OPTIONS
;					  ||||||||_______________TMR1ON - TIMER1 ON BIT
;					  |||||||________________TMR1CS - TIMER1 CLOCK SOURCE SELECT BIT
;					  ||||||_________________T1SYNC - TIMER1 EXTERNAL CLOCK INPUT SYNCRINIZATION CONTROL BIT
;					  |||||__________________T1OSCEN - TIMER1 OCILATOR ENABLE BIT
;					  ||||___________________T1CKPS0 - TIMER1 INPUT CLOCK PRESCALE SELECT BITS
;					  |||____________________T1CKPS1 - TIMER1 INPUT CLOCK PRESCALE SELECT BITS
;					  ||_____________________UNIMPLEMENTED
;					  |______________________UNIMPLEMENTED
			MOVWF		T1CON
			CALL		T1_RESET			;RESET TIMER1
			BSF		STATUS,RP0		;BANK1
			BSF		PIE1,TMR1IE		;TIMER1 INTERRUPT ENABLE BIT

;==========================================================================================================================
;	INIT MESSAGE OUT RS232 PORT
;==========================================================================================================================
			BCF		STATUS,RP0		;BANK0
			MOVLW		HIGH TABLE_POR	;PRINT OUT MESSAGE
			MOVWF		TEXT_TABLE_H
			MOVLW		LOW TABLE_POR
			CALL		TEXT_TABLE
;==========================================================================================================================
;	MAIN PROGRAM LOOP
;==========================================================================================================================
MAIN
			BCF		STATUS,RP0		;BANK 0
			BTFSC		RCSTA,1			;CHECK FOR SERIAL PORT OVERRUN
			CALL		SERIAL_RESET		;SKIP THIS LINE IF SERIAL PORT IS A-O-K
			BTFSC		RCSTA,2			;CHECK FOR SERIAL PORT FRAMING ERROR
			CALL		SERIAL_RESET		;SKIP THIS LINE IF SERIAL PORT IS A-O-K
			GOTO		MAIN			;REPEAT MAIN PROGRAM

SERIAL_RESET		BCF		RCSTA,SPEN		;DISABLE SERIAL PORT TO CLEAR ERROR
			BCF		RCSTA,CREN		;DISABLE CONTINUOUS RECEIVE (TO CLEAR OVERRUN)
			BSF		RCSTA,CREN		;ENABLE CONTINUOUS RECEIVE
			BSF		RCSTA,SPEN		;RE-ENABLE SERIAL PORT
			RETURN					;RETURN TO MAIN LOOP

;==========================================================================================================================
;	TIMER0 OVERFLOW INTERRUPT
;	RELOCK THE DOOR
;==========================================================================================================================
T0_OVRFL
	; Note! we get here every 256 instructions, we
	; can now do our special one second timing system.

			DECFSZ		BRES_LO,F
			GOTO		T0_EXIT

			BCF		STATUS,RP0		;BANK 0
			BSF		PORT_WIEGAND,WG_LED_RED			;TURN RED LED OFF
			BSF		PORT_WIEGAND,WG_LED_GREEN			;TURN GREEN LED OFF
			BSF		PORT_WIEGAND,WG_BUZZER			;TURN BUZZER OFF
			BCF		PORT_RELAY,RELAY_0				;TURN OFF RELAY
T0_EXIT
			BCF 		INTCON,TMR0IF			; reset the tmr0 interrupt flag
			BTFSC		INTCON,TMR0IF			;ENSURE THE INTERRUPT FLAG IS CLEAR
			GOTO		T0_EXIT
			RETURN
;==========================================================================================================================
;	TIMER1 OVERFLOW INTERRUPT
;	RESET THE RECEIVED WINGAND DATA BUFFER
;==========================================================================================================================
T1_OVRFL
			BCF		T1CON,TMR1ON			;TURN TIMER1 OFF
			BCF		PIR1,TMR1IF			;CLEAR TIMER1 INTERRUPT FLAG
			CALL		T1_RESET			;RESET TIMER1

			;RESET THE BUFFER
			CLRF		WG_DATA_COUNTER			;CLEAR THE DATA INPUT COUNTER
			RETURN						;RETURN

;==========================================================================================================================
;	TIMER1 RESET
;==========================================================================================================================
T1_RESET		CLRF		TMR1H
			CLRF		TMR1L
			BSF		T1CON,T1CKPS0
			BSF		T1CON,T1CKPS1
			RETURN

;==========================================================================================================================
;	GET DATA FROM THE WIEGAND DEVICE
;==========================================================================================================================
WIEGAND_GET
			;WE ARE GOING TO GET DATA FROM THE WIEGAND DEVICE HERE
			;FIRST WE NEED TO FIND OUT IF WE GOT A ONE OR A ZERO

			;CHECK TO SEE IF DATA 0 LINE IS LOW (ACTIVE LOW)
			BTFSS		PORT_WIEGAND,WG_D0		;IS DATA ON THE 0 LINE? SKIP NEXT IF HIGH (NODATA)
			BCF		WG_DATA_TEMP,0			;PUSH THE VALUE INTO WIEGAND_TEMP

			;CHECK TO SEE IF DATA 1 LINE IS LOW (ACTIVE LOW)
			BTFSS		PORT_WIEGAND,WG_D1		;IS DATA ON THE 1 LINE? SKIP NEXT IF HIGH (NODATA)
			BSF		WG_DATA_TEMP,0			;PUSH THE VALUE INTO WIEGAND_TEMP

			INCF		WG_DATA_COUNTER,F		;INCRIMENT OUR COUNTER TO SHOW WE GOT ANOTHER BIT

			;IF THIS IS THE FIRST BIT THEN IT IS A PARTIY EVEN BIT
			MOVLW		H'01'				;1 BIT RECEIVED?
			SUBWF		WG_DATA_COUNTER,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_PARITY_E

			;CHECK TO SEE IF ONE IF THE BYTES IS READY TO BE TRANSFERED
			MOVLW		H'09'				;9 BITS RECEIVED?
			SUBWF		WG_DATA_COUNTER,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_DONE_00

			MOVLW		H'11'				;17 BITS RECEIVED?
			SUBWF		WG_DATA_COUNTER,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_DONE_01

			MOVLW		H'19'				;25 BITS RECEIVED?
			SUBWF		WG_DATA_COUNTER,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_DONE_02

			MOVLW		H'1A'				;26 BITS RECEIVED?
			SUBWF		WG_DATA_COUNTER,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_PARITY_O

			RLF		WG_DATA_TEMP,F			;OTHERWISE RORATE AND RETURN
			GOTO		WIEGAND_END

WIEGAND_PARITY_E
		;START TIMER HERE TO RESET IF DATA IS NOT RECEIVED
			BSF		T1CON,TMR1ON			;TURN TIMER1 ON

			BTFSC		WG_DATA_TEMP,0
			BCF		WG_DATA_STATUS,WG_PARITY_E
			BTFSS		WG_DATA_TEMP,0
			BSF		WG_DATA_STATUS,WG_PARITY_E
			GOTO		WIEGAND_END
WIEGAND_DONE_00
			;COPY CONTENTS TO 00 DATA BYTE
			MOVF		WG_DATA_TEMP,W
			MOVWF		WG_DATA_00
			GOTO		WIEGAND_END
WIEGAND_DONE_01
			;COPY CONTENTS TO 01 DATA BYTE
			MOVF		WG_DATA_TEMP,W
			MOVWF		WG_DATA_01
			GOTO		WIEGAND_END
WIEGAND_DONE_02
			;COPY CONTENTS TO 02 DATA BYTE
			MOVF		WG_DATA_TEMP,W
			MOVWF		WG_DATA_02
			GOTO		WIEGAND_END
WIEGAND_PARITY_O
		;STOP THE TIMER
			BCF		T1CON,TMR1ON			;TURN TIMER1 OFF

			BTFSC		WG_DATA_TEMP,0
			BCF		WG_DATA_STATUS,WG_PARITY_O
			BTFSS		WG_DATA_TEMP,0
			BSF		WG_DATA_STATUS,WG_PARITY_O
			CLRF		WG_DATA_COUNTER


			;COPY THE WIEGAND DATA OUT INTO THE PROPER REGISTERS FOR COMPARISON AND PRINTING
			MOVF		WG_DATA_00,W
			MOVWF		CARD_SITEID_SCANNED
			MOVF		WG_DATA_01,W
			MOVWF		CARD_CARDID_HIGH_SCANNED
			MOVF		WG_DATA_02,W
			MOVWF		CARD_CARDID_LOW_SCANNED


			;DO ANYTHING ELSE HERE WE WANT AFTER A CARD IS READ
			;WE WILL IMPLEMENT A ROUTINE TO SCAN THE MEMORY FOR CARDS HERE
			;EACH CARD CONSISTS OF THREE BYTES THAT WE NEED TO CHECK FOR
			;SO WE NEED TO KEEP TRACK OF A COUPLE THINGS
			;THE CARD DATA READ WILL BE IN WG_DATA_00, WG_DATA_01, WG_DATA_02

			;IT IS EASY TO CHECK A CARD
			;VALUES ARE ALREADY STORED IN CARD_SITEID, CARD_CARDID_HIGH, AND CARD_CARDID_LOW
			MOVF		CARD_SITEID_SCANNED,W		;COPY SCANNED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_SITEID_SEARCH
			MOVF		CARD_CARDID_HIGH_SCANNED,W	;COPY SCANNED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_CARDID_HIGH_SEARCH
			MOVF		CARD_CARDID_LOW_SCANNED,W	;COPY SCANNED DATA INTO SERACH REGISTERS
			MOVWF		CARD_CARDID_LOW_SEARCH
			CALL		CARD_SEARCH			;SEARCH FOR THE CARD
			ANDLW		H'03'				;VERIFY THE CARD IS ACTIVE
			XORLW		H'03'
			BTFSC		STATUS,Z
			GOTO		WIEGAND_CHECK_GOOD		;IF SUCCESS, OPEN THE DOOR

WIEGAND_CHECK_FAIL
			MOVLW		'F'				;SEND OUT A "F"
			CALL		RS232_TX_GO
			MOVLW		'A'				;SEND OUT A "A"
			CALL		RS232_TX_GO
			MOVLW		'I'				;SEND OUT A "I"
			CALL		RS232_TX_GO
			MOVLW		'L'				;SEND OUT A "L"
			CALL		RS232_TX_GO

			;RESET THE TIMER FOR TURNING OFF THE RED LED AND BUZZER
			MOVLW		H'20'
			MOVWF		BRES_LO

			;ADD CODE TO DO SOMETHING WHEN FAIL
			BCF			PORT_WIEGAND,WG_LED_RED			;TURN RED LED OFF
			BCF			PORT_WIEGAND,WG_BUZZER			;TURN BUZZER OFF

			GOTO		WIEGAND_PRINT
WIEGAND_CHECK_GOOD
			MOVLW		'P'				;SEND OUT A "P"
			CALL		RS232_TX_GO
			MOVLW		'A'				;SEND OUT A "A"
			CALL		RS232_TX_GO
			MOVLW		'S'				;SEND OUT A "S"
			CALL		RS232_TX_GO
			MOVLW		'S'				;SEND OUT A "S"
			CALL		RS232_TX_GO

WIEGAND_CHECK_GOOD_ACTION
			;ADD CODE TO DO SOMETHING WHEN SUCCESS
			BCF		PORT_WIEGAND,WG_LED_GREEN

			;RESET THE TIMER FOR TURNING OFF THE RELAY AND GREEN LED
			MOVLW		H'40'
			MOVWF		BRES_LO

			;TURN ON THE DOOR RELAY, IT WILL AUTOMATICALLY TURN BACK OFF FROM THE TIMER INTERRUPT
			BSF		PORT_RELAY,RELAY_0		;TURN ON DOOR

			GOTO		WIEGAND_PRINT

WIEGAND_PRINT		;OUTPUT DISPLAY DATA OUT RS232 (SITEID AND CARDID)
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		CARD_SITEID_SCANNED,W		;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVLW		' '				;SEND OUT A " "
			CALL		RS232_TX_GO

			MOVF		RXIN_02,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVLW		'-'				;OUTPUT A SPACE
			CALL		RS232_TX_GO

			MOVF		CARD_CARDID_HIGH_SCANNED,W
			MOVWF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		CARD_CARDID_LOW_SCANNED,W	;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_00,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_01,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_02,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		CARD_FILEID,W
			BTFSC		STATUS,Z
			GOTO		WIEGAND_PRINT_END

			MOVLW		' '				;SEND OUT A " "
			CALL		RS232_TX_GO

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SUCCESS_2;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SUCCESS_2	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVF		CARD_FILEID,W
			CALL		HEX_TO_DEC_ASCII		;CONVERT CARD_FILEID DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SUCCESS_3;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SUCCESS_3	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVF		CARD_FILEID,W
			CALL		RS232_NAME_STRING_PRINT	;PRINT OUT THE NAME ASSOCIATED WITH THIS FILEID
WIEGAND_PRINT_END
			CALL		RS232_TX_CRLF			;SEND OUT CRLF

WIEGAND_END		BCF		INTCON,INTF			;CLEAR INTERRUPT FLAG
			BTFSC		INTCON,INTF			;VERIFY IT IS CLEAR
			GOTO		WIEGAND_END			;IR IT IS NOT CLEAR REPEAT UNTIL IT IS CLEAR
			RETURN

WIEGAND_CLEAR		CLRF		WG_DATA_COUNTER			;CLEAR THE DATA INPUT COUNTER
WIEGAND_CLEAR_L		BCF		PIR1, TMR1IF			;CLEAR THE INTERRUPT
			BTFSC		PIR1, TMR1IF			;VERIFY IT IS CLEAR
			GOTO		WIEGAND_CLEAR_L

			CALL		T1_RESET			;RESET TIMER1
			RETURN

;==========================================================================================================================
;	CAPTURE DATA FROM THE RS232 PORT
;==========================================================================================================================
RS232_GET
			CALL		RS232_RX_GO
			;WHAT DO WE WANT TO DO HERE?
			;LETS USE D FOR DOOR THEN THAT WILL OPEN THE DOOR
			;SO, CHECK TO SEE WHERE THE BUFFER IS FIRST
			;WE WILL CREATE A VARIABLE RXIN0 AND RXIN1, ALONG WITH RXIN_STATUS TO HELP US KNOW WHAT
			;BYTE WE ARE GETTING

			MOVLW		H'0D'				;CHECK FOR CR H'0D'
			SUBWF		RXIN,0				;GOTO INPUT SUB IF RECEIVED
			BTFSC		STATUS,2			;CHARACTER IS EQUAL TO "CR", THEN SKIP THE GOTO STATEMENT
			GOTO		RS232_GET_CHECK

			MOVLW		H'08'				;CHECK FOR BACKSPACE H'08'
			SUBWF		RXIN,0				;GOTO INPUT SUB IF RECEIVED
			BTFSC		STATUS,2			;CHARACTER IS EQUAL TO "CR", THEN SKIP THE GOTO STATEMENT
			GOTO		RS232_GET_BACKSPACE

			MOVLW		H'7F'				;CHECK FOR BACKSPACE H'7F'
			SUBWF		RXIN,0				;GOTO INPUT SUB IF RECEIVED
			BTFSC		STATUS,2			;CHARACTER IS EQUAL TO "CR", THEN SKIP THE GOTO STATEMENT
			GOTO		RS232_GET_BACKSPACE

			;FIRST CHECK THE STATUS OF THE RXIN_POSITION, IF BUFFER FULL WE DONT WANT TO ACCEPT THE BYTE
			MOVLW		RXIN_1F				;CHECK FOR OVERBUFFER
			ADDLW		H'01'
			SUBWF		RXIN_POSITION,W
			BTFSC		STATUS,Z			;IF WE ARE OVER BUFFER, STOP HERE
			RETURN

			;STORE THE BYTE
			MOVF		RXIN_POSITION,W			;GET THE CURRENT BUFFER POSITION
			MOVWF		FSR
			INCF		RXIN_POSITION,F			;INCF THE BUFFER POSITION FOR RXIN
			MOVF		RXIN,W				;GET THE RECEIVED BYTE
			MOVWF		INDF				;PLACE THE CONTENTS IN THE INDIRECT REGISTER POINTER
			CALL		RS232_TX_GO			;ECHO OUT THE BYTE FOR USE FEEDBACK
			RETURN						;RETURN TO MAIN TO WAIT FOR NEXT CHARACTER

RS232_GET_CHECK		MOVLW		RXIN_00				;LOAD BUFFER START POSITION INTO FSR
			MOVWF		FSR				;MOV STARTING POSITION BUFFER
			SUBWF		RXIN_POSITION,W			;CHECK IF WE HAVE ANY DATA IN THE BUFFER
			BTFSC		STATUS,Z
			GOTO		RS232_GET_NODATA		;IF THERE IS NO DATA IN THE BUFFER, CHECK IF WE ARE IN A STATE
T_CHECK_LOOP
;			CALL		RS232_TX_CRLF			;SEND OUT CRLF
;			MOVF		INDF,W				;DUMP OUT THE BUFFER
;			MOVWF		TXOUT
;			CALL		RS232_TX_GO
;			INCF		FSR,F
;			MOVF		FSR,W				;CHECK IF FSR = RXIN_BUFFER, IF NOT SKIP
;			SUBWF		RXIN_POSITION,W
;			BTFSS		STATUS,Z
;			GOTO		RS232_GET_CHECK_LOOP

			;DO SOMETHING USEFUL WITH THE DATA HERE
			;CHECK THE STATE OF THE RS232 TO SEE WHAT WE ARE WAITING ON
			;DIFFERENT STATES IS AS FOLLOWS
			;(MOVED TO TOP OF PROGRAM FILE)

			GOTO		STATE_HANDLER

STATE_HANDLER_ERROR	MOVLW		'?'
			CALL		RS232_TX_GO
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
STATE_HANDLER_DONE	MOVLW		RXIN_00				;RESET THE BUFFER
			MOVWF		RXIN_POSITION
			RETURN
RS232_GET_NODATA	MOVF		SYSTEM_STATE,F			;CHECK IF WE ARE IN A STATE OTHER THAN H'00'
			BTFSC		STATUS,Z
			RETURN						;IF WE ARE NOT IN A STATE, JUST RETURN
			CLRF		SYSTEM_STATE			;IF WE ARE IN A STATE, CLEAR IT AND RETURN
			MOVLW		HIGH TABLE_RS232_GET_ABORT	;PRINT OUT MESSAGE
			MOVWF		TEXT_TABLE_H
			MOVLW		LOW TABLE_RS232_GET_ABORT
			CALL		TEXT_TABLE
			RETURN						;RETURN
RS232_GET_BACKSPACE	;MAKE SURE WE ARE NOT AT START OF BUFFER, WE CANT BACKSPACE PAST THAT
			MOVLW		RXIN_00
			MOVWF		FSR				;MOV STARTING POSITION BUFFER
			SUBWF		RXIN_POSITION,W			;CHECK IF WE HAVE ANY DATA IN THE BUFFER
			BTFSC		STATUS,Z
			RETURN						;DO NOTHING IF WE CAN'T BACKSPACE
			DECF		RXIN_POSITION,F			;DECF THE RXIN_POSITION
			MOVLW		H'08'				;SEND BACKSPACE TO THE TERMINAL
			CALL		RS232_TX_GO
			MOVLW		' '				;SEND BACKSPACE TO THE TERMINAL
			CALL		RS232_TX_GO
			MOVLW		H'08'				;SEND BACKSPACE TO THE TERMINAL
			CALL		RS232_TX_GO
			RETURN						;RETURN IMMEDIATLY

;==========================================================================================================================
;	STATE HANDLER, WE MUST RETURN FROM HERE SINCE WE ARE STILL IN THE STACK FROM RS232 RECEPTION
;==========================================================================================================================
STATE_HANDLER		MOVF		SYSTEM_STATE,F			;CHECK FOR STATE H'00'
			BTFSC		STATUS,Z
			GOTO		STATE_HANDLER_00

			MOVLW		H'10'				;CHECK FOR STATE H'10'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADD_10

			MOVLW		H'11'				;CHECK FOR STATE H'11'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADD_11

			MOVLW		H'12'				;CHECK FOR STATE H'12'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADD_12

			MOVLW		H'30'				;CHECK FOR STATE H'30'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_SEARCH_ENTRY_10

			MOVLW		H'31'				;CHECK FOR STATE H'31'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_SEARCH_ENTRY_11

			MOVLW		H'40'				;CHECK FOR STATE H'40'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		CARD_DELETE_40

			MOVLW		H'50'				;CHECK FOR STATE H'50'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_READ_50

			MOVLW		H'51'				;CHECK FOR STATE H'51'
			SUBWF		SYSTEM_STATE,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_READ_51
			GOTO		STATE_HANDLER_ERROR		;IF NO STATES MATCH, RETURN WITH ERROR


STATE_HANDLER_00	;HANDLE STATE H'00'
			MOVLW		H'21'				;CHECK IF WE RECEIVED ONE CHARACTER
			SUBWF		RXIN_POSITION,W
			BTFSC		STATUS,Z
			GOTO		STATE_HANDLER_00_01

			MOVLW		H'22'				;CHECK IF WE RECEIVED TWO CHARACTERS
			SUBWF		RXIN_POSITION,W
			BTFSC		STATUS,Z
			GOTO		STATE_HANDLER_00_02
			GOTO		STATE_HANDLER_ERROR

STATE_HANDLER_00_01	MOVLW		'?'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		PRINT_MENU

			MOVLW		'a'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADD

			MOVLW		'b'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADDSCAN

			MOVLW		'd'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		CARD_DELETE

			MOVLW		's'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		CARD_SEARCH_ENTRY

			MOVLW		'v'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		PRINT_VERSION
			GOTO		STATE_HANDLER_ERROR

STATE_HANDLER_00_02	MOVLW		'l'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		STATE_HANDLER_00_02_l

			MOVLW		'm'
			SUBWF		RXIN_00,W
			BTFSC		STATUS,Z
			GOTO		STATE_HANDLER_00_02_m
			GOTO		STATE_HANDLER_ERROR

STATE_HANDLER_00_02_l	;MOVLW		'c'
			;SUBWF		RXIN_01,W
			;BTFSC		STATUS,Z
			;GOTO		TEXT_CARD_LIST_CARDID

			MOVLW		'f'
			SUBWF		RXIN_01,W
			BTFSC		STATUS,Z
			GOTO		CARD_LIST_FILEID

			;MOVLW		'n'
			;SUBWF		RXIN_01,W
			;BTFSC		STATUS,Z
			;GOTO		TEXT_CARD_LIST_NAME
			GOTO		STATE_HANDLER_ERROR

STATE_HANDLER_00_02_m
;			MOVLW		'e'
;			SUBWF		RXIN_01,W
;			BTFSC		STATUS,Z
;			GOTO		MEMORY_ERASE_ALL

;			MOVLW		'f'
;			SUBWF		RXIN_01,W
;			BTFSC		STATUS,Z
;			GOTO		MEMORY_READ_FAT

;			MOVLW		'n'
;			SUBWF		RXIN_01,W
;			BTFSC		STATUS,Z
;			GOTO		MEMORY_READ

			MOVLW		'r'
			SUBWF		RXIN_01,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_ERASE_FAT

;			MOVLW		't'
;			SUBWF		RXIN_01,W
;			BTFSC		STATUS,Z
;			GOTO		MEMORY_FILL_FAT
			GOTO		STATE_HANDLER_ERROR

PRINT_MENU		;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MENU			;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MENU			;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232
			GOTO		STATE_HANDLER_DONE

PRINT_VERSION		;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_VERSION		;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_VERSION		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232
			GOTO		STATE_HANDLER_DONE

CARD_ADD		;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_SITEID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_SITEID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'10'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE
CARD_ADD_10		;CHECK INPUT OF SITEID AND DO SOMETHING
			;DOES THE INPUT CONSIST OF ONE CHARACTER?

			CALL		RXIN_TO_HEX
			ADDLW		0				;CHECK IF WE GOT AN ERROR IN CONVERSION
			BTFSS		STATUS,Z			;ERROR WILL RETURN NON 0
			GOTO		CARD_ADD_10_ERROR
			MOVF		TEMP_HEX_HIGH,F			;CHECK IF TEMP_HEX_HIGH IS ZERO, SHOULD BE, OTHERWISE TOO BIG
			BTFSS		STATUS,Z
			GOTO		CARD_ADD_10_ERROR		;PRINT OUT ERROR MESSAGE

			MOVF		TEMP_HEX_LOW,W			;COPY THE RESULTS OF THE CONVERSION
			MOVWF		CARD_SITEID

			;DONE WITH SITEID, CHANGE STATE AND CONTINUE
CARD_ADD_10_AGAIN	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_CARDID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_CARDID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'11'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

CARD_ADD_10_ERROR	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		CARD_ADD			;PRINT OUT THE ENTRY MESSAGE AGAIN

CARD_ADD_11		;GETS THE RXIN INPUT AND CONVERTS IT TO TWO HEX BYTES, MOVED OFF TO A SUBROUTINE
			CALL		RXIN_TO_HEX
			ADDLW		0				;CHECK IF WE GOT AN ERROR IN CONVERSION
			BTFSS		STATUS,Z			;ERROR WILL RETURN NON 0
			GOTO		CARD_ADD_11_ERROR

			MOVF		TEMP_HEX_HIGH,W			;COPY THE RESULTS OF THE CONVERSION
			MOVWF		CARD_CARDID_HIGH
			MOVF		TEMP_HEX_LOW,W
			MOVWF		CARD_CARDID_LOW

CARD_ADD_11_CHECKDUP	;CHECK IF WE HAVE A DUPLICATE CARD FIRST, ATTEMPT TO SEARCH FOR IT, WILL RETURN H'00' IF IS NOT FOUND
			MOVF		CARD_SITEID,W			;COPY ENTERED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_SITEID_SEARCH
			MOVF		CARD_CARDID_HIGH,W		;COPY ENTERED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_CARDID_HIGH_SEARCH
			MOVF		CARD_CARDID_LOW,W		;COPY ENTERED DATA INTO SERACH REGISTERS
			MOVWF		CARD_CARDID_LOW_SEARCH

			CALL		CARD_SEARCH
			ADDLW		0
			BTFSS		STATUS,Z
			GOTO		CARD_ADD_11_DUPLICATE
			;IF NOT DUPLICATE, CONTINUE BY SEARCHING FOR A FREE PLACE IN MEMORY
			;TO DO THIS, WE NEED TO LOOK AT EACH FAT ENTRY UNTIL WE FIND ONE WITH A '1' IN A BIT, THIS
			;TELLS US THAT THAT SPECIFIC PAGE IS EMTPY AND WE CAN STORE OUT DATA THERE

			;IF WE GOT HERE, INPUT IS OKAY, CONTINUE TO NEXT STEP
			;OUTPUT THE NEXT STEP'S HELP TEXT AND CHANGE STATE

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_NAME	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_NAME		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'12'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR NAME
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

CARD_ADD_11_ERROR	;PRINT OUT AN ERROR MESSAGE
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		CARD_ADD_10_AGAIN		;PRINT OUT THE ENTRY MESSAGE AGAIN
CARD_ADD_11_DUPLICATE	;IF WE TRIED TO ADD A CARD ALREADY IN THE SYSTEM
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_DUPLICATE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_DUPLICATE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			CLRF		SYSTEM_STATE			;RESET SYSTEM STATE
			GOTO		STATE_HANDLER_DONE

CARD_ADD_12		;CHECK INPUT OF NAME AND DO SOMETHING

			;FIND A FREE PLACE TO WRITE HERE
			;WE NEED TO LOOK AT EACH FAT AND FIND THE FIRST FREE PLACE

			;SET THE INITIAL VALUE FOR THE FAT POINTER

			CLRF		FAT_POINTER			;FAT_POINTER = H'00'
			CLRF		CARD_FILEID			;CLEAR THE FILEID NUMBER

CARD_ADD_12_SEARCH	CLRF		ADDR_H				;SET ADDRESSES FOR EEPROM READ
			MOVF		FAT_POINTER,W			;HIGH ADDRESS IS JUST CLEARED
			MOVWF		ADDR_L				;LOW ADDRESS IS THE FAT_POINTER

			CALL		RDBYTE_START			;OPEN THE EEPROM
			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA FROM THE EEPROM
			MOVWF		FAT_DATA			;PUT INTO THE FAT DATA REGISTER
			CALL		RDBYTE_STOP			;CLOSE OUT THE EEPROM

			MOVF		FAT_POINTER,W			;SET THE HIGH BYTE FOR MEMORY ACCESS
			MOVWF		ADDR_H

			;WE NEED TO MASK OFF BIT7 IN THE FIRST ADDRESS, THAT IS THE FAT TABLE, DON'T WANT TO WRITE THERE
			MOVF		FAT_POINTER,F
			BTFSC		STATUS,Z
			BCF		FAT_DATA,7

			;CHECK THE INDIVIDUAL BITS, EACH BIT REPRESENTS A DIFFERENT MEMORY PAGE
			BTFSC		FAT_DATA,7			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT0		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,6			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT1		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,5			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT2		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,4			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT3		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,3			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT4		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,2			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT5		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,1			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT6		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSC		FAT_DATA,0			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			GOTO		CARD_ADD_12_FAT7		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F

			INCF		FAT_POINTER,F

			MOVLW		H'20'
			SUBWF		FAT_POINTER,W
			BTFSC		STATUS,Z
			GOTO		CARD_ADD_12_NOMEM		;IF WE DID ALL MEMORY ADDRESSES, WE ARE DONE, NO MEMORY FREE
			GOTO		CARD_ADD_12_SEARCH		;IF WE AREN'T DONE, DO THE NEXT MEMORY POINTER

CARD_ADD_12_FAT0	MOVLW		H'00'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,7			;CLEAR BIT 7 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT1	MOVLW		H'20'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,6			;CLEAR BIT 6 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT2	MOVLW		H'40'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,5			;CLEAR BIT 5 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT3	MOVLW		H'60'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,4			;CLEAR BIT 4 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT4	MOVLW		H'80'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,3			;CLEAR BIT 3 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT5	MOVLW		H'A0'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,2			;CLEAR BIT 2 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT6	MOVLW		H'C0'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,1			;CLEAR BIT 1 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE
CARD_ADD_12_FAT7	MOVLW		H'E0'
			MOVWF		PAGE_POINTER
			BCF		FAT_DATA,0			;CLEAR BIT 0 OF THE FAT, INDICATES WE HAVE DATA NOW
			GOTO		CARD_ADD_12_WRITE

CARD_ADD_12_WRITE	;WRITE TO MEMORY HERE
			MOVF		FAT_POINTER,W
			MOVWF		ADDR_H
			MOVF		PAGE_POINTER,W
			MOVWF		ADDR_L
			CALL		WRBYTE_START

			MOVLW		H'03'				;CARD IS NOT DELETED, AND ACTIVE
			MOVWF		DATAO
			CALL		WRBYTE_DATA

			MOVF		CARD_SITEID,W
			MOVWF		DATAO
			CALL		WRBYTE_DATA

			MOVF		CARD_CARDID_HIGH,W
			MOVWF		DATAO
			CALL		WRBYTE_DATA

			MOVF		CARD_CARDID_LOW,W
			MOVWF		DATAO
			CALL		WRBYTE_DATA

			;WRITE THE ASCII DATA, WHICH SHOULD STILL BE IN THE BUFFER
			MOVLW		RXIN_00				;SET THE POINTER TO THE FIRST BUFFER
			MOVWF		FSR

CARD_ADD_12_LOOP	MOVF		INDF,W				;GET DATA FROM THE BUFFER
			MOVWF		DATAO
			CALL		WRBYTE_DATA			;WRITE A BYTE INTO EEPROM

			INCF		FSR,F				;INCF POINTER TO NEXT BUFFER BYTE
			MOVF		FSR,W				;CHECK IF FSR = RXIN_BUFFER
			SUBWF		RXIN_POSITION,W			;IF EQUAL THEN WE ARE DONE, ADD ONE MORE 00 BYTE
			BTFSC		STATUS,Z
			GOTO		CARD_ADD_12_DONE		;FINISH

			;CHECK IF WE ARE AT MAX SIZE, NAME CAN BE AT MOST 27 BYTES LONG
			;THIS MEANS THAT IF FSR IS AT H'3F' THEN WE ARE DONE
			MOVLW		H'3B'
			SUBWF		FSR,W
			BTFSC		STATUS,C
			GOTO		CARD_ADD_12_DONE
			GOTO		CARD_ADD_12_LOOP

CARD_ADD_12_DONE	MOVLW		H'00'				;ADD THE H'00' (END OF STRING) BYTE
			MOVWF		DATAO
			CALL		WRBYTE_DATA			;ADD LAST BYTE
			CALL		WRBYTE_STOP

			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;RESTORE BIT 7 IN THE FIRST ADDRESS, IT NEEDS TO BE THERE IF WE REMOVED IT
			MOVF		FAT_POINTER,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,7

			CLRF		ADDR_H				;WRITE IN THE FAT INFORMATION
			MOVF		FAT_POINTER,W
			MOVWF		ADDR_L
			CALL		WRBYTE_START
			MOVF		FAT_DATA,W
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			CALL		WRBYTE_STOP

			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_DONE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_DONE		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232


			;PRINT OUT THE FILEID
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		CARD_FILEID,W			;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO
			MOVF		RXIN_03,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO
			MOVF		RXIN_04,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO


			CALL		RS232_TX_CRLF
			CLRF		SYSTEM_STATE			;RESET SYSTEM STATE
			GOTO		STATE_HANDLER_DONE
CARD_ADD_12_NOMEM	;NO MEMORY TO ADD THE CARD, MEMORY FULL
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_NOMEM	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_NOMEM	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			CLRF		SYSTEM_STATE			;RESET SYSTEM STATE
			GOTO		STATE_HANDLER_DONE
CARD_DELETE		;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_DELETE_FILEID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_DELETE_FILEID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'40'				;SYSTEM_STATE = IN CARD DELETE MODE, WAITING FOR FILEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE
CARD_DELETE_40		;WE NEED TO CONVERT THE ENTRY AND THEN CHECK IF IT IS VALID
			CALL		RXIN_TO_HEX
			ADDLW		0				;CHECK IF WE GOT AN ERROR IN CONVERSION
			BTFSS		STATUS,Z			;ERROR WILL RETURN NON 0
			GOTO		CARD_DELETE_40_ERROR

			MOVF		TEMP_HEX_HIGH,F			;CHECK IF TEMP_HEX_HIGH IS ZERO, SHOULD BE, OTHERWISE TOO BIG
			BTFSS		STATUS,Z
			GOTO		CARD_DELETE_40_ERROR		;PRINT OUT ERROR MESSAGE

			MOVF		TEMP_HEX_LOW,F			;CHECK IF TEMP_HEX_LOW IS ZERO, SHOULD NOT BE
			BTFSC		STATUS,Z			;WE CAN'T ACCEPT ZERO ENTRY, IT WILL ERASE OUR FAT TABLE!
			GOTO		CARD_DELETE_40_ERROR		;PRINT OUT ERROR MESSAGE

			MOVF		TEMP_HEX_LOW,W			;COPY THE RESULTS OF THE CONVERSION
			MOVWF		CARD_FILEID

			;NOW, HOW TO FIND THE CORRECT FAT BYTE TO MESS WITH???
			MOVWF		FAT_POINTER
			BCF		STATUS,C			;CLEAR THE CARRY
			RRF		FAT_POINTER,F			;ROTATE TO THE RIGHT ONCE
			BCF		STATUS,C			;CLEAR THE CARRY
			RRF		FAT_POINTER,F			;ROTATE TO THE RIGHT ONCE
			BCF		STATUS,C			;CLEAR THE CARRY
			RRF		FAT_POINTER,F			;ROTATE TO THE RIGHT ONCE
			MOVF		FAT_POINTER,W
			MOVWF		ADDR_L

			;NOW WE CAN GRAB THE FAT BYTE OUT OF MEMORY
			CLRF		ADDR_H
			CALL		RDBYTE_START			;OPEN THE EEPROM
			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA FROM THE EEPROM
			MOVWF		FAT_DATA			;PUT INTO THE FAT DATA REGISTER
			CALL		RDBYTE_STOP			;CLOSE OUT THE EEPROM

			;NOW WE NEED TO CHANGE THE BYTE
			MOVLW		H'07'
			ANDWF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,7
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,6
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,5
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,4
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,3
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,2
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,1
			DECF		CARD_FILEID,F
			BTFSC		STATUS,Z
			BSF		FAT_DATA,0

			CLRF		ADDR_H				;WRITE IN THE FAT INFORMATION
			MOVF		FAT_POINTER,W
			MOVWF		ADDR_L
			CALL		WRBYTE_START
			MOVF		FAT_DATA,W
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			CALL		WRBYTE_STOP

			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_DELETE_DONE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_DELETE_DONE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232


			CLRF		SYSTEM_STATE			;CLEAR THE SYSTEM STATE
			GOTO		STATE_HANDLER_DONE		;RETURN
CARD_DELETE_40_ERROR	;PRINT ERROR MESSAGE
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		CARD_DELETE			;REPRINT THE MESSAGE
			GOTO		STATE_HANDLER_DONE		;RETURN

CARD_LIST_FILEID
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_LIST_FILEID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_LIST_FILEID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			;SET THE INITIAL VALUE FOR THE FREE SPACE COUNTER SO WE CAN SEE HOW MUCH FREE MEMORY WE HAVE
			CLRF		FREE_MEMORY_COUNTER

			;SET THE INITIAL VALUE FOR THE FAT POINTER
			CLRF		FAT_POINTER			;FAT_POINTER = H'00'
			CLRF		CARD_FILEID			;CLEAR THE FILEID NUMBER

CARD_LIST_FILEID_LOOP	CLRF		ADDR_H				;SET ADDRESSES FOR EEPROM READ
			MOVF		FAT_POINTER,W			;HIGH ADDRESS IS JUST CLEARED
			MOVWF		ADDR_L				;LOW ADDRESS IS THE FAT_POINTER

			CALL		RDBYTE_START			;OPEN THE EEPROM
			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA FROM THE EEPROM
			MOVWF		FAT_DATA			;PUT INTO THE FAT DATA REGISTER
			CALL		RDBYTE_STOP			;CLOSE OUT THE EEPROM

			MOVF		FAT_POINTER,W			;SET THE HIGH BYTE FOR MEMORY ACCESS
			MOVWF		ADDR_H

			;GET LOWER ADDRESS BYTE
			BTFSS		FAT_DATA,7			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT0		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,6			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT1		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,5			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT2		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,4			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT3		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,3			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT4		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,2			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT5		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,1			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT6		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,0			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_LIST_FILEID_FAT7		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			INCF		CARD_FILEID,F

			INCF		FAT_POINTER,F

			MOVLW		H'20'
			SUBWF		FAT_POINTER,W
			BTFSS		STATUS,Z
			GOTO		CARD_LIST_FILEID_LOOP		;IF WE AREN'T DONE, DO THE NEXT MEMORY POINTER

			;IF WE GOT HERE, WE ARE DONE, PRINT OUT THE MEMORY INFORMATION, USED, FREE, TOTAL, ETC

			;PRINT OUT MEMORY SUMMARY TEXTS
			CALL		RS232_TX_CRLF
			MOVLW		HIGH TABLE_LF	;PRINT OUT MESSAGE
			MOVWF		TEXT_TABLE_H
			MOVLW		LOW TABLE_LF
			CALL		TEXT_TABLE

			;PRINT OUT THE USED MEMORY INFORMATION
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		FREE_MEMORY_COUNTER,W			;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO
			CALL		RS232_TX_CRLF

			MOVLW		'F'
			CALL		RS232_TX_GO
			MOVLW		'R'
			CALL		RS232_TX_GO
			MOVLW		'E'
			CALL		RS232_TX_GO
			MOVLW		'E'
			CALL		RS232_TX_GO
			MOVLW		':'
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO

			;PRINT OUT THE FREE MEMORY INFORMATION
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		FREE_MEMORY_COUNTER,W			;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			SUBLW		H'FF'
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO
			CALL		RS232_TX_CRLF

			GOTO		STATE_HANDLER_DONE		;IF WE DID ALL MEMORY ADDRESSES, WE ARE DONE

CARD_LIST_FILEID_FAT0	MOVLW		H'00'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT1	MOVLW		H'20'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT2	MOVLW		H'40'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT3	MOVLW		H'60'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT4	MOVLW		H'80'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT5	MOVLW		H'A0'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT6	MOVLW		H'C0'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN
CARD_LIST_FILEID_FAT7	MOVLW		H'E0'
			MOVWF		ADDR_L
			CALL		CARD_LIST_FILEID_PAGEREAD
			RETURN

CARD_LIST_FILEID_PAGEREAD
			CALL		RDBYTE_START			;OPEN THE EEPROM
			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA TO WREG
			MOVWF		CARD_STATUS			;CARD STATUS INFORMATION

			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA TO WREG
			MOVWF		CARD_SITEID			;CARD SITEID INFORMATION

			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA TO WREG
			MOVWF		CARD_CARDID_HIGH		;CARD SITEID INFORMATION

			CALL		RDBYTE_DATA			;GET THE FAT BYTE FROM EEPROM
			MOVF		DATAI,W				;COPY DATA TO WREG
			MOVWF		CARD_CARDID_LOW			;CARD SITEID INFORMATION

			;PRINT OUT THIS INFORMATION FIRST, CONVERTING IT FROM HEX TO DECIMAL
			;WE CAN USE THE RXIN BUFFER SINCE IT IS NOT USED AT THIS TIME

			;PRINT OUT THE FILEID
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		CARD_FILEID,W			;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE FILEID BYTES
			CALL		RS232_TX_GO

			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO

			;PRINT OUT THE SITEID
			CLRF		TEMP_HIGH			;CLEAR HIGH BYTE, NOT NEEDED
			MOVF		CARD_SITEID,W			;COPY IN SITEID BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_02,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE SITEID BYTES
			CALL		RS232_TX_GO

			MOVLW		'-'				;OUTPUT A DASH
			CALL		RS232_TX_GO

			;PRINT OUT THE CARDID
			MOVF		CARD_CARDID_HIGH,W		;COPY IN CARDID_HIGH BYTE FOR HEX TO DEC ASCII CONVERSION
			MOVWF		TEMP_HIGH
			MOVF		CARD_CARDID_LOW,W		;COPY IN CARDID_LOW BYTE FOR HEX TO DEC ASCII CONVERSION
			CALL		HEX_TO_DEC_ASCII		;CONVERT TEMP_HIGH AND TEMP_LOW TO DECIMAL ASCII
									;RESULT WILL BE IN RXIN_00 THROUGH RXIN_04
			MOVF		RXIN_00,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_01,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_02,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_03,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVF		RXIN_04,W			;PRINT OUT THE CARDID BYTES
			CALL		RS232_TX_GO

			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO
			MOVLW		' '				;OUTPUT A SPACE
			CALL		RS232_TX_GO

			;PRINT OUT THE NAME STRING
			MOVLW		H'1F'
			MOVWF		RDBYTE_COUNTER
CARD_LIST_FILEID_PAGEREAD_NAME
			CALL		RDBYTE_DATA
			MOVF		DATAI,W
			CALL		RS232_TX_GO
			MOVF		DATAI,F
			BTFSC		STATUS,Z
			GOTO		CARD_LIST_FILEID_PAGEREAD_END
			DECFSZ		RDBYTE_COUNTER,F
			GOTO		CARD_LIST_FILEID_PAGEREAD_NAME

CARD_LIST_FILEID_PAGEREAD_END
			CALL		RDBYTE_STOP
			CALL		RS232_TX_CRLF			;SEND OUT CRLF

			INCF		FREE_MEMORY_COUNTER,F	;INCF THE MEMORY COUNTER SO WE CAN SEE HOW MUCH MEMORY IS USED

			RETURN						;THIS PAGE IS DONE READING, RETURN

CARD_SEARCH_ENTRY	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SITEID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SITEID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232


			MOVLW		H'30'			;SYSTEM_STATE = IN CARD SEARCH ENTRY MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE
CARD_SEARCH_ENTRY_10	;CHECK INPUT OF SITEID AND DO SOMETHING
			;DOES THE INPUT CONSIST OF ONE CHARACTER?

			CALL		RXIN_TO_HEX
			ADDLW		0				;CHECK IF WE GOT AN ERROR IN CONVERSION
			BTFSS		STATUS,Z			;ERROR WILL RETURN NON 0
			GOTO		CARD_SEARCH_ENTRY_10_ERROR
			MOVF		TEMP_HEX_HIGH,F			;CHECK IF TEMP_HEX_HIGH IS ZERO, SHOULD BE, OTHERWISE TOO BIG
			BTFSS		STATUS,Z
			GOTO		CARD_SEARCH_ENTRY_10_ERROR	;PRINT OUT ERROR MESSAGE

			MOVF		TEMP_HEX_LOW,W			;COPY THE RESULTS OF THE CONVERSION
			MOVWF		CARD_SITEID_KEYED

			;DONE WITH SITEID, CHANGE STATE AND CONTINUE
CARD_SEARCH_ENTRY_10_AGAIN
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADD_CARDID	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADD_CARDID	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'31'				;SYSTEM_STATE = IN CARD SEARCH ENTRY MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

CARD_SEARCH_ENTRY_10_ERROR
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		CARD_SEARCH_ENTRY		;PRINT OUT THE ENTRY MESSAGE AGAIN

CARD_SEARCH_ENTRY_11	;GETS THE RXIN INPUT AND CONVERTS IT TO TWO HEX BYTES, MOVED OFF TO A SUBROUTINE
			CALL		RXIN_TO_HEX
			ADDLW		0				;CHECK IF WE GOT AN ERROR IN CONVERSION
			BTFSS		STATUS,Z			;ERROR WILL RETURN NON 0
			GOTO		CARD_SEARCH_ENTRY_11_ERROR

			MOVF		TEMP_HEX_HIGH,W			;COPY THE RESULTS OF THE CONVERSION
			MOVWF		CARD_CARDID_HIGH_KEYED
			MOVF		TEMP_HEX_LOW,W
			MOVWF		CARD_CARDID_LOW_KEYED

			;IF WE GOT HERE, INPUT IS OKAY, CONTINUE TO NEXT STEP
			;OUTPUT THE NEXT STEP'S HELP TEXT AND CHANGE STATE

			MOVF		CARD_SITEID_KEYED,W		;COPY ENTERED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_SITEID_SEARCH
			MOVF		CARD_CARDID_HIGH_KEYED,W	;COPY ENTERED DATA INTO SEARCH REGISTERS
			MOVWF		CARD_CARDID_HIGH_SEARCH
			MOVF		CARD_CARDID_LOW_KEYED,W		;COPY ENTERED DATA INTO SERACH REGISTERS
			MOVWF		CARD_CARDID_LOW_SEARCH

			CALL		CARD_SEARCH			;SEARCH FOR THE CARD
			ADDLW		H'00'
			BTFSC		STATUS,Z			;CHECK IF WE FAILED TO FIND THE CARD
			GOTO		CARD_SEARCH_ENTRY_11_FAIL	;FAILED TO FIND CARD
			MOVWF		DATAI				;MOVE INTO DATAI FOR MEM_READ_TX

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SUCCESS	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SUCCESS	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			CALL		MEM_READ_TX

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SUCCESS_2;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SUCCESS_2	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			CLRF		TEMP_HIGH
			MOVF		CARD_FILEID,W
			CALL		HEX_TO_DEC_ASCII
			MOVF		RXIN_02,W
			CALL		RS232_TX_GO
			MOVF		RXIN_03,W
			CALL		RS232_TX_GO
			MOVF		RXIN_04,W
			CALL		RS232_TX_GO

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_SUCCESS_3;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_SUCCESS_3	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVF		CARD_FILEID,W
			CALL		RS232_NAME_STRING_PRINT	;PRINT OUT THE NAME ASSOCIATED WITH THIS FILEID

			GOTO		CARD_SEARCH_ENTRY_11_END
CARD_SEARCH_ENTRY_11_FAIL
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_SEARCH_FAIL	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_SEARCH_FAIL	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

CARD_SEARCH_ENTRY_11_END
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			CLRF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

CARD_SEARCH_ENTRY_11_ERROR
			;PRINT OUT AN ERROR MESSAGE
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		CARD_SEARCH_ENTRY_10_AGAIN	;PRINT OUT THE ENTRY MESSAGE AGAIN

CARD_SEARCH		CLRF		FAT_POINTER			;CLEAR THE FAT POINTER
			CLRF		CARD_FILEID			;CLEAR THE CARD_FILEID POINTER
CARD_SEARCH_LOOP	CLRF		ADDR_H				;GET A FAT BYTE
			MOVF		FAT_POINTER,W
			MOVWF		ADDR_L
			BTFSS		CHIP_OPEN,0			;CHECK IF THE CHIP IS OPEN
			CALL		RDBYTE_START			;START EEPROM COMMUNICATION
			BSF		CHIP_OPEN,0			;MARK CHIP AS OPEN SO WE DONT CALL IT AGAIN
			CALL		RDBYTE_DATA			;GET A BYTE FROM THE EEPROM
			MOVF		DATAI,W
			MOVWF		FAT_DATA			;STORE THE BYTE SO WE CAN WORK WITH IT

			MOVLW		H'00'				;CLEAR OUT WREG SO IT DOESNT BOGGLE UP OUR BTFSS STATEMENTS

			BTFSS		FAT_DATA,7			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT0		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,6			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT1		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,5			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT2		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,4			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT3		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,3			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT4		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,2			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT5		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,1			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT6		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F
			BTFSS		FAT_DATA,0			;CHECK IF WE HAVE INFORMATION IN THIS PAGE
			CALL		CARD_SEARCH_FAT7		;PRINT OUT THE DATA FOR PAGE XXXX XXXX XXX0 0000
			ADDLW		0				;CHECK IF WE GOT A NON ZERO RETURN, MEANS WE ARE DONE
			BTFSS		STATUS,Z
			RETURN						;RETURN WITH CARD_STATUS IN WREG

			INCF		CARD_FILEID,F

			MOVLW		H'1F'				;CHECK IF WE HAVE LOOKED THROUGH ALL THE FAT
			SUBWF		FAT_POINTER,W
			BTFSC		STATUS,Z			;IS FAT_POINTER = H'1F'?
			GOTO		CARD_SEARCH_END			;HAVE HIT THE END OF THE FAT, SO STOP
			INCF		FAT_POINTER,F
			GOTO		CARD_SEARCH_LOOP

CARD_SEARCH_END		CALL		RDBYTE_STOP			;CLOSE THE MEMORY CHIP
			BCF		CHIP_OPEN,0			;MARK THE MEMORY CHIP AS CLOSED
			RETLW		0				;RETURN WITH FAILURE TO FIND CARD

CARD_SEARCH_FAT0	MOVLW		H'00'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT1	MOVLW		H'20'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT2	MOVLW		H'40'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT3	MOVLW		H'60'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT4	MOVLW		H'80'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT5	MOVLW		H'A0'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT6	MOVLW		H'C0'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE
CARD_SEARCH_FAT7	MOVLW		H'E0'				;SET THE LOWER MEMORY ADDRESS, START OF THE PAGE
			MOVWF		ADDR_L
			GOTO		CARD_SEARCH_PAGEREAD		;READ THE PAGE

CARD_SEARCH_PAGEREAD	MOVF		FAT_POINTER,W			;SET THE HIGH ADDRESS BYTE, ALWAYS FROM FAT_POINTER
			MOVWF		ADDR_H
			CALL		RDBYTE_STOP			;CLOSE THE CHIP FIRST
			CALL		RDBYTE_START			;START THE EEPROM READING
			CALL		RDBYTE_DATA			;GET THE CARD_STATUS BYTE
			MOVF		DATAI,W
			MOVWF		CARD_STATUS
			CALL		RDBYTE_DATA			;GET THE CARD_SITEID BYTE
			MOVF		DATAI,W
			SUBWF		CARD_SITEID_SEARCH,W		;CHECK IF THE CARD_SITEID MATCHES
			BTFSS		STATUS,Z			;IF IT MATCHES, CONTINUE
			GOTO		CARD_SEARCH_PAGEREAD_E		;IF IT DOESN'T MATCH, EXIT
			CALL		RDBYTE_DATA			;GET THE CARD_CARDID_HIGH BYTE
			MOVF		DATAI,W
			SUBWF		CARD_CARDID_HIGH_SEARCH,W	;CHECK IF THE CARD_CARDID_HIGH MATCHES
			BTFSS		STATUS,Z			;IF IT MATCHES CONTINUE
			GOTO		CARD_SEARCH_PAGEREAD_E		;IF IT DOESN'T MATCH, END
			CALL		RDBYTE_DATA			;GET THE CARD_CARDID_LOW BYTE
			MOVF		DATAI,W
			SUBWF		CARD_CARDID_LOW_SEARCH,W	;CHECK IF THE CARD_CARDID_LOW MATCHES
			BTFSS		STATUS,Z			;IF IT MATCHES, CONTINUE
			GOTO		CARD_SEARCH_PAGEREAD_E		;IF IT DOESN'T MATCH, END

			;IF WE GOT HERE, THE CARD MATCHES, SO RETURN THE STATUS
			BCF		CHIP_OPEN,0			;MARK CHIP AS CLOSED
			CALL		RDBYTE_STOP
			MOVF		CARD_STATUS,W
			RETURN						;RETURN SUCCESS TO FIND CARD
CARD_SEARCH_PAGEREAD_E	BCF		CHIP_OPEN,0			;MARK CHIP AS CLOSED
			CALL		RDBYTE_STOP			;CLOSE THE MEMORY CHIP
			RETLW		0				;RETURN FAILURE TO FIND CARD
CARD_ADDSCAN		MOVF		CARD_SITEID_SCANNED,W		;COPY THE SCANNED CARD DATA TO THE ENTERED DATA REGISTERS
			MOVWF		CARD_SITEID
			MOVF		CARD_CARDID_HIGH_SCANNED,W
			MOVWF		CARD_CARDID_HIGH
			MOVF		CARD_CARDID_LOW_SCANNED,W
			MOVWF		CARD_CARDID_LOW

			;PRINT OUT MESSAGE
			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ADDSCAN		;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ADDSCAN		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232


			;PRINT OUT THE SITEID FOR THE SCANNED CARD
			CLRF		TEMP_HIGH			;CLEAR THE TEMP_HIGH REGISTER
			MOVF		CARD_SITEID,W
			CALL		HEX_TO_DEC_ASCII
			MOVF		RXIN_02,W
			CALL		RS232_TX_GO
			MOVF		RXIN_03,W
			CALL		RS232_TX_GO
			MOVF		RXIN_04,W
			CALL		RS232_TX_GO

			MOVLW		'-'
			CALL		RS232_TX_GO

			;PRINT OUT THE CARDID FOR THE SCANNED CARD
			MOVF		CARD_CARDID_HIGH,W
			MOVWF		TEMP_HIGH
			MOVF		CARD_CARDID_LOW,W
			CALL		HEX_TO_DEC_ASCII
			MOVF		RXIN_00,W
			CALL		RS232_TX_GO
			MOVF		RXIN_01,W
			CALL		RS232_TX_GO
			MOVF		RXIN_02,W
			CALL		RS232_TX_GO
			MOVF		RXIN_03,W
			CALL		RS232_TX_GO
			MOVF		RXIN_04,W
			CALL		RS232_TX_GO

			GOTO		CARD_ADD_11_CHECKDUP		;FORWARD TO THE CARD ADD ROUTINE, SINCE ALL SAME AFTER THIS

MEMORY_READ_FAT	CALL			RS232_TX_CRLF			;SEND OUT CRLF
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			MOVLW		H'00'
			MOVWF		ADDR_H				;SET HIGH ADDRESS TO ZERO
			MOVLW		H'00'
			MOVWF		ADDR_L				;SET LOW ADDRESS TO ZERO
			CALL		RDBYTE_START			;START UP THE RECEIVE FROM THE EEPROM
MEMORY_READ_FAT_LOOP	CALL		RDBYTE_DATA			;RECEIVE ONE BYTE FROM THE EEPROM
			CALL		MEM_READ_TX			;OUTPUT ONE CHARACTER
			MOVLW		' '				;ADD A SPACE BETWEEN OUTPUTS TO MAKE IT EASIER TO READ
			CALL		RS232_TX_GO

			MOVLW		H'0F'				;CHECK IF WE NEED A CRLF
			ANDWF		ADDR_L,W
			SUBLW		H'0F'
			BTFSC		STATUS,Z			;IF WE NEED A CRLF THEN ZERO FLAG WILL BE SET
			CALL		RS232_TX_CRLF			;SEND OUT CRLF

			INCF		ADDR_L,F			;INCF OUR ADDRESS COUNTER
			MOVLW		H'20'				;CHECK IF WE ACCESSED ALL FAT
			SUBWF		ADDR_L,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_READ_FAT_END		;IF ALL FAT WAS ACCESSED, END
			GOTO		MEMORY_READ_FAT_LOOP		;IF WE STILL HAVE MORE TO READ, LOOP
MEMORY_READ_FAT_END	CALL		RDBYTE_STOP			;CLOSE OUT THE EEPROM
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			GOTO		STATE_HANDLER_DONE

MEMORY_ERASE_FAT	CLRF		ADDR_H				;ERASE AND RESET THE FAT IN THE CHIP
			CLRF		ADDR_L
			CALL		WRBYTE_START
MEMORY_ERASE_FAT_LOOP	MOVLW		H'FF'
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			INCF		ADDR_L,F
			MOVLW		H'20'
			SUBWF		ADDR_L,W
			BTFSS		STATUS,Z
			GOTO		MEMORY_ERASE_FAT_LOOP
			CALL		WRBYTE_STOP
			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_ERASE		;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_ERASE		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		STATE_HANDLER_DONE		;DONE, RETURN

MEMORY_FILL_FAT		CLRF		ADDR_H				;FILL THE FAT UP IN THE CHIP, ALL FAT ENTRIES ACTIVE
			CLRF		ADDR_L
			CALL		WRBYTE_START
			MOVLW		H'80'
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			INCF		ADDR_L,F
MEMORY_FILL_FAT_LOOP	MOVLW		H'00'
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			INCF		ADDR_L,F
			MOVLW		H'20'
			SUBWF		ADDR_L,W
			BTFSS		STATUS,Z
			GOTO		MEMORY_FILL_FAT_LOOP
			CALL		WRBYTE_STOP
			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_FILL		;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_FILL		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		STATE_HANDLER_DONE		;DONE, RETURN

MEMORY_ERASE_ALL	CLRF		ADDR_H				;ERASE AND RESET THE FAT IN THE CHIP
			CLRF		ADDR_L
			CALL		WRBYTE_START
MEMORY_ERASE_ALL_LOOP	MOVLW		H'FF'
			MOVWF		DATAO
			CALL		WRBYTE_DATA
			INCF		ADDR_L,F
			BTFSC		STATUS,Z
			INCF		ADDR_H,F
			MOVLW		H'20'
			SUBWF		ADDR_L,W
			ANDLW		H'1F'
			BTFSS		STATUS,Z
			GOTO		MEMORY_ERASE_ALL_LOOP

			CALL		WRBYTE_STOP
			;DELAY FOR CHIP TO RECOVER
			CALL		DELAY_NMS

			;ARE WE ALL DONE?  DID WE DO FROM 0000h TO 01FFh
			MOVLW		H'20'
			SUBWF		ADDR_H,W
			BTFSS		STATUS,Z
			GOTO		MEMORY_ERASE_ALL_NEXT

			MOVF		ADDR_L,F
			BTFSS		STATUS,Z
			GOTO		MEMORY_ERASE_ALL_NEXT
			GOTO		MEMORY_ERASE_ALL_END

MEMORY_ERASE_ALL_NEXT	;START THE NEXT MEMORY PAGE
			;WRITE THAT MEMORY PAGE WAS ERASED!
			MOVLW		'.'
			CALL		RS232_TX_GO
			CALL		WRBYTE_START
			GOTO		MEMORY_ERASE_ALL_LOOP

MEMORY_ERASE_ALL_END	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_ERASE		;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_ERASE		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		STATE_HANDLER_DONE		;DONE, RETURN

MEMORY_READ		;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_READ_S	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_READ_S		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'50'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

MEMORY_READ_50		;GETS THE RXIN INPUT AND CONVERTS IT TO TWO HEX BYTES, MOVED OFF TO A SUBROUTINE
			;CHECK THE SIZE OF THE ENTRY, IT CAN ONLY BE TWO BYTES (FOUR CHARACTERS)
			MOVLW		H'25'
			SUBWF		RXIN_POSITION,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_READ_50_ERROR

			MOVF		RXIN_00,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_50_ERROR
			MOVWF		MEM_READ_START_H
			SWAPF		MEM_READ_START_H,F

			MOVF		RXIN_01,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_50_ERROR
			IORWF		MEM_READ_START_H,F
			;SWAPF		MEM_READ_START_H,F

			MOVF		RXIN_02,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_50_ERROR
			MOVWF		MEM_READ_START_L
			SWAPF		MEM_READ_START_L,F

			MOVF		RXIN_03,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_50_ERROR
			IORWF		MEM_READ_START_L,F
			;SWAPF		MEM_READ_START_L,F

MEMORY_READ_50_AGAIN	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_READ_E	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_READ_E		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			MOVLW		H'51'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

MEMORY_READ_50_ERROR	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		MEMORY_READ			;PRINT OUT THE ENTRY MESSAGE AGAIN

MEMORY_READ_51		;GETS THE RXIN INPUT AND CONVERTS IT TO TWO HEX BYTES, MOVED OFF TO A SUBROUTINE
			;CHECK THE SIZE OF THE ENTRY, IT CAN ONLY BE TWO BYTES (FOUR CHARACTERS)
			MOVLW		H'25'
			SUBWF		RXIN_POSITION,W
			BTFSC		STATUS,Z
			GOTO		MEMORY_READ_51_ERROR

			MOVF		RXIN_00,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_51_ERROR
			MOVWF		MEM_READ_END_H
			SWAPF		MEM_READ_END_H,F

			MOVF		RXIN_01,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_51_ERROR
			IORWF		MEM_READ_END_H,F
			;SWAPF		MEM_READ_END_H,F

			MOVF		RXIN_02,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_51_ERROR
			MOVWF		MEM_READ_END_L
			SWAPF		MEM_READ_END_L,F

			MOVF		RXIN_03,W
			CALL		RXIN_CHECK
			MOVWF		TEMP
			BTFSC		TEMP,7
			GOTO		MEMORY_READ_51_ERROR
			IORWF		MEM_READ_END_L,F
			;SWAPF		MEM_READ_END_L,F

MEMORY_READ_51_AGAIN	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_MEMORY_READ_E	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_MEMORY_READ_E		;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			;WE GATHERED ALL INFO FROM THE USER AND ERROR CHECKED IT, NOW USE IT
			;DO THE STUFF HERE
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			MOVF		MEM_READ_START_H,W
			MOVWF		ADDR_H				;SET HIGH ADDRESS TO ZERO
			MOVF		MEM_READ_START_L,W
			MOVWF		ADDR_L				;SET LOW ADDRESS TO ZERO
			CALL		RDBYTE_START			;START UP THE RECEIVE FROM THE EEPROM
MEMORY_READ_51_LOOP	CALL		RDBYTE_DATA			;RECEIVE ONE BYTE FROM THE EEPROM
			CALL		MEM_READ_TX			;OUTPUT ONE CHARACTER

			MOVLW		H'0F'				;CHECK IF WE NEED A CRLF
			ANDWF		ADDR_L,W
			SUBLW		H'0F'
			BTFSC		STATUS,Z			;IF WE NEED A CRLF THEN ZERO FLAG WILL BE SET
			CALL		RS232_TX_CRLF			;SEND OUT CRLF

			;ARE WE ALL DONE?  DID WE DO FROM 0000h TO 01FFh
			MOVF		MEM_READ_END_L,W
			SUBWF		ADDR_L,W
			BTFSS		STATUS,Z
			GOTO		MEMORY_READ_51_NEXT

			MOVF		MEM_READ_END_H,W
			SUBWF		ADDR_H,W
			BTFSS		STATUS,Z
			GOTO		MEMORY_READ_51_NEXT
			GOTO		MEMORY_READ_51_END

MEMORY_READ_51_NEXT	INCF		ADDR_L,F			;INCF OUR ADDRESS COUNTER
			BTFSC		STATUS,Z
			INCF		ADDR_H,F
			GOTO		MEMORY_READ_51_LOOP

MEMORY_READ_51_END	CALL		RDBYTE_STOP			;CLOSE OUT THE EEPROM
			CALL		RS232_TX_CRLF			;SEND OUT CRLF
			CLRF		SYSTEM_STATE			;RESET SYSTEM STATE
			GOTO		STATE_HANDLER_DONE




			MOVLW		H'51'				;SYSTEM_STATE = IN CARD ADD MODE, WAITING FOR SITEID
			MOVWF		SYSTEM_STATE
			GOTO		STATE_HANDLER_DONE

MEMORY_READ_51_ERROR	;NEXT FOUR LINES PRINT OUT A SELECTED TEXT TABLE, TABLE NAME FOLLOWS "HIGH" AND "LOW", MUST BE SAME TABLE BOTH LINES
			MOVLW		HIGH TABLE_CARD_ERROR_PARSE	;GRAB THE HIGH BYTE OF THE STRING TABLE WE WILL OUTPUT TO RS232
			MOVWF		TEXT_TABLE_H			;TEXT_TABLE_H STORES THE TABLE START ADDRESS
			MOVLW		LOW TABLE_CARD_ERROR_PARSE	;TEXT_TABLE_L IS STORED IN WREG, MOVED TO TEXT_TABLE_L AFTER CALL
			CALL		TEXT_TABLE			;OUTPUT THE SELECTED TABLE TO RS232

			GOTO		MEMORY_READ_50_AGAIN		;PRINT OUT THE ENTRY MESSAGE AGAIN


MEM_READ_TX		MOVF		DATAI,0
			MOVWF		TEMP
			MOVLW		H'F0'
			ANDWF		TEMP,1
			SWAPF		TEMP,1
			MOVLW		H'30'				;MOV 30h INTO W
			ADDWF		TEMP,1				;ADD W TO TEMP (ADD 30h)
			MOVLW		H'3A'				;DETERMINE IF TEMP IS ABOVE 39h
			SUBWF		TEMP,0
			BTFSS		3,0
			GOTO		MEM_READ_TX_1			;IF IT IS NOT THEN RETURN
			MOVLW		H'07'				;IF IT IS THEN MOV 07h INTO W
			ADDWF		TEMP,1				;AND ADD W INTO TEMP TO MAKE IT A CHARACTER
MEM_READ_TX_1
			MOVF		TEMP,0
			CALL		RS232_TX_GO

			MOVF		DATAI,0
			MOVWF		TEMP
			MOVLW		H'0F'
			ANDWF		TEMP,1
			MOVLW		H'30'				;MOV 30h INTO W
			ADDWF		TEMP,1				;ADD W TO TEMP (ADD 30h)
			MOVLW		H'3A'				;DETERMINE IF TEMP IS ABOVE 39h
			SUBWF		TEMP,0
			BTFSS		3,0
			GOTO		MEM_READ_TX_2			;IF IT IS NOT THEN RETURN
			MOVLW		H'07'				;IF IT IS THEN MOV 07h INTO W
			ADDWF		TEMP,1				;AND ADD W INTO TEMP TO MAKE IT A CHARACTER
MEM_READ_TX_2
			MOVF		TEMP,0
			CALL		RS232_TX_GO
			MOVLW		' '
			CALL		RS232_TX_GO
			RETURN

RS232_NAME_STRING_PRINT
;==========================================================================================================================
;	PRINTS OUT THE ASCII STRING FOR A SPECIFIED FILEID (HELD IN WREG WHEN CALLED)
;	RETURNS NOTHING, JUST PRINTS OUT THE ASCII STRING BYTES OUT RS232
;	ADDR_L AND ADDR_H HOLD THE ADDRESS TO START READING FROM THE MEMORY CHIP
;==========================================================================================================================
			MOVWF		ADDR_L			;MOV CONTENTS FROM WREG (THE FILEID WE WANT TO CHECK) TO ADDR_L
			CLRF		ADDR_H			;CLEAR ADDR_H TO PREPARE FOR SHIFTING
			RLF			ADDR_L,F		;ROTATE ADDR_L TO GET THE START ADDRESS, WE NEED TO DO THIS 5 TIMES
			RLF			ADDR_H,F		;ROTATE A BIT INTO ADDR_H IF IT WENT INTO CARRY

			RLF			ADDR_L,F		;ROTATE ADDR_L TO GET THE START ADDRESS, WE NEED TO DO THIS 4 MORE TIMES
			RLF			ADDR_H,F		;ROTATE A BIT INTO ADDR_H IF IT WENT INTO CARRY

			RLF			ADDR_L,F		;ROTATE ADDR_L TO GET THE START ADDRESS, WE NEED TO DO THIS 3 MORE TIMES
			RLF			ADDR_H,F		;ROTATE A BIT INTO ADDR_H IF IT WENT INTO CARRY

			RLF			ADDR_L,F		;ROTATE ADDR_L TO GET THE START ADDRESS, WE NEED TO DO THIS 2 MORE TIMES
			RLF			ADDR_H,F		;ROTATE A BIT INTO ADDR_H IF IT WENT INTO CARRY

			RLF			ADDR_L,F		;ROTATE ADDR_L TO GET THE START ADDRESS, WE NEED TO DO THIS 1 MORE TIMES
			RLF			ADDR_H,F		;ROTATE A BIT INTO ADDR_H IF IT WENT INTO CARRY

			MOVLW		B'11100000'		;AND B'11100000' INTO ADDR_L TO WIPE THE LOWER 5 BITS
			ANDWF		ADDR_L,F		;DO THE AND

			MOVLW		H'04'			;MOV THE STARTING LOWER 5 BITS INTO ADDR_L WHERE THE ASCII STRING STARTS
			IORWF		ADDR_L,F		;OR THE LOWER 5 BITS INTO ADDR_L

			;PRINT OUT THE NAME STRING
			MOVLW		H'1F'
			MOVWF		RDBYTE_COUNTER
			CALL		RDBYTE_START
RS232_NAME_STRING_PRINT_LOOP
			CALL		RDBYTE_DATA
			MOVF		DATAI,W
			CALL		RS232_TX_GO
			MOVF		DATAI,F
			BTFSC		STATUS,Z
			GOTO		RS232_NAME_STRING_PRINT_END
			DECFSZ		RDBYTE_COUNTER,F
			GOTO		RS232_NAME_STRING_PRINT_LOOP

RS232_NAME_STRING_PRINT_END
			CALL		RDBYTE_STOP
			RETURN

RXIN_ASCII_TO_HEX
;==========================================================================================================================
;	RXIN (ASCII) TO HEX CONVERSION (CONVERTS UP TO A 16 BIT NUMBER)
;	SOURCE IS IN RXIN_00 (MSB) THROUGH RXIN_04 (LSB)
;	RETURNED BYTES WILL BE IN TEMP_LOW (LOW BYTE), AND TEMP_HIGH (HIGH BYTE)
;==========================================================================================================================
RXIN_TO_HEX		;CHECK INPUT OF CARDID AND DO SOMETHING

			CLRF		TEMP_HEX_HIGH			;CLEAR THE HIGH BYTE OF THE CARDID
			CLRF		TEMP_HEX_LOW			;CLEAR THE LOW BYTE OF THE CARDID
			MOVLW		RXIN_00				;GET ADDRESS FOR FIRST BUFFER BYTE
			MOVWF		FSR				;SET THE ADDRESS POINTER
RXIN_TO_HEX_LOOP	MOVF		INDF,W				;GET THE FIRST BYTE FROM THE BUFFER
			CALL		ASCII_TO_HEX			;CONVERT FROM ASCII TO HEX
			ADDWF		TEMP_HEX_LOW,F			;START BUILDING THE CARDID BYTES (TWO)
			SUBLW		H'0F'				;CHECK IF THE ASCII TO HEX HAD A VALID RESULT
			BTFSC		STATUS,Z			;INVALID CHARACTER WILL RETURN H'OF'
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF INVALID INPUT
			MOVF		RXIN_POSITION,W			;CHECK IF IF THERE IS ANOTHER DIGIT TO WORK ON
			SUBWF		FSR,W				;IF FSB=RXIN_POSITION THEN WE ARE DONE
			ADDLW		H'01'				;ADD ONE MORE TO SEE IF WE GET A ZERO
			BTFSC		STATUS,Z			;IF WE GET A ZERO, THEY EQUAL AND WE ARE DONE
			GOTO		RXIN_TO_HEX_DOUBLECHECK		;DONE WITH DIGITS, DOUBLECHECK THE RESULT
									;RESULT STORED IN TEMP_HEX_HIGH AND TEMP_HEX_LOW
			;THE NEXT PARTS MULTIPLY THE CARDID LOW BY TEN
			;MULTIPLY BY TWO
			MOVF		TEMP_HEX_LOW,W
			MOVWF		TEMP_LOW
			MOVF		TEMP_HEX_HIGH,W			;KEEP THE CARDID LOW BYTE FOR MULTIPLICATOIN SOON
			MOVWF		TEMP_HIGH
			BCF		STATUS,C			;CLEAR CARRY
			RLF		TEMP_HEX_LOW,F			;MULTIPLY CARDID LOW BYTE BY TWO
			RLF		TEMP_HEX_HIGH,F			;WE NEED TO ROTATE THE HIGH BYTE TOO
			BTFSC		STATUS,C			;CHECK FOR CARRY, IF WE GET A CARRY HERE, THE NUMBER IS TOO BIG
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF NUMBER IS TOO BIG

			;MULTIPLY BY TWO, TOTAL RESULT IS NOW MULTIPLIED BY FOUR
			BCF		STATUS,C			;CLEAR CARRY
			RLF		TEMP_HEX_LOW,F			;MULTIPLY CARDID LOW BYTE BY TWO
			RLF		TEMP_HEX_HIGH,F			;WE NEED TO ROTATE THE HIGH BYTE TOO
			BTFSC		STATUS,C			;CHECK FOR CARRY, IF WE GET A CARRY HERE, THE NUMBER IS TOO BIG
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF NUMBER IS TOO BIG

			;ADD ORIGINAL ONE TIME, TOTAL RESULT IS NOW MULTIPLIED BY FIVE
			MOVF		TEMP_LOW,W			;RETRIEVE THE ORIGINAL VALUE AND ADD IT ONCE TO THE RESULT
			ADDWF		TEMP_HEX_LOW,F			;MULTIPLY CARDID LOW BYTE BY TWO
			MOVLW		H'01'				;MOV H'01' TO WREG TO PREPARE FOR ADDLW OPERATION
			BTFSC		STATUS,C			;CHECK FOR CARRY
			ADDWF		TEMP_HEX_HIGH,F			;IF CARRY, WE NEED TO INCF THE CARDID HIGH BYTE
			BTFSC		STATUS,C			;CHECK FOR CARRY, IF WE GET A CARRY HERE, THE NUMBER IS TOO BIG
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF NUMBER IS TOO BIG
			MOVF		TEMP_HIGH,W			;ADD THE HIGH BYTE ALSO, DON'T FORGET ABOUT IT
			ADDWF		TEMP_HEX_HIGH,F
			BTFSC		STATUS,C			;CHECK FOR CARRY, IF WE GET A CARRY HERE, THE NUMBER IS TOO BIG
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF NUMBER IS TOO BIG

			;MULTIPLY BY TWO, TOTAL RESULT IS NOW MUILTIPLED BY TEN, WHAT WE NEEDED TO DO
			BCF		STATUS,C			;CLEAR CARRY
			RLF		TEMP_HEX_LOW,F			;MULTIPLY CARDID LOW BYTE BY TWO
			RLF		TEMP_HEX_HIGH,F			;WE NEED TO ROTATE THE HIGH BYTE TOO
			BTFSC		STATUS,C			;CHECK FOR CARRY, IF WE GET A CARRY HERE, THE NUMBER IS TOO BIG
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR MESSAGE IF NUMBER IS TOO BIG

			INCF		FSR,F				;INCF THE POINTER TO CHECK THE NEXT BYTE
			GOTO		RXIN_TO_HEX_LOOP		;CHECK FOR NEXT DIGIT
			RETLW		0				;RETURN, RESULT IS IN TEMP_HEX_HIGH AND TEMP_HEX_LOW
RXIN_TO_HEX_ERROR	RETLW		H'0F'				;RETURN, ERROR IN CONVERSION
RXIN_TO_HEX_DOUBLECHECK MOVF		INDF,W				;CHECK IF WE GOT A CARRY ON LAST ADD, WHICH MEANS
			CALL		ASCII_TO_HEX			;IF WE GOT A BORROW HERE, THEN WE GOT A CARRY
			SUBWF		TEMP_HEX_LOW,W			;CHECK FOR A BORROW HERE
			BTFSS		STATUS,C			;A CARRY WILL RESULT IN STATUS,C BEING CLEAR
			GOTO		RXIN_TO_HEX_ERROR		;GENERATE ERROR
			RETLW		0				;RETURN SUCCESS
;==========================================================================================================================
;	HEX TO DECIMAL CONVERSION (CONVERTS UP TO A 16 BIT NUMBER)
;	SOURCE IS IN TEMP_LOW (LOW BYTE), AND TEMP_HIGH (HIGH BYTE)
;	RETURNED BYTES WILL BE IN RXIN_00 (MSB) THROUGH RXIN_04 (LSB)
;==========================================================================================================================
HEX_TO_DEC_ASCII
			CLRF		RXIN_00				;CLEAR RESULT REGISTERS
			CLRF		RXIN_01
			CLRF		RXIN_02
			CLRF		RXIN_03
			CLRF		RXIN_04
;			MOVF		TEMP_LOW,W		;TEMP_LOW IS ALREADY IN WREG, SO DON'T NEED TO MOV IT OUT
			MOVWF		TEMP_LOW
			MOVWF		TEMP_LOW_WORKING
			MOVF		TEMP_HIGH,W
			MOVWF		TEMP_HIGH_WORKING

HEX_TO_DEC_ASCII_10000_L;CAN WE SUBTRACT D'10000' H'2710' FROM TEMP_HIGH AND TEMP_LOW??
			MOVLW		H'10'				;SUBTRACT H'10' FROM TEMP_LOW
			SUBWF		TEMP_LOW_WORKING,F
			MOVLW		H'01'				;PREPARE FOR SUBTRACTION
			BTFSS		STATUS,C			;WAS THERE A BORROW?
			SUBWF		TEMP_HIGH_WORKING,F		;SUBTRACT H'01' FROM TEMP_HIGH IF WE BORROWED
			BTFSS		STATUS,C			;WAS THERE A BORROW? IF THERE WAS WE SKIP TO NEXT
			GOTO		HEX_TO_DEC_ASCII_1000
			MOVLW		H'27'
			SUBWF		TEMP_HIGH_WORKING,F
			BTFSS		STATUS,C			;WAS THERE A BORROW? IF THERE WAS WE SKIP TO NEXT
			GOTO		HEX_TO_DEC_ASCII_1000
			MOVF		TEMP_LOW_WORKING,W		;STORE CURRENT RESULTS
			MOVWF		TEMP_LOW
			MOVF		TEMP_HIGH_WORKING,W
			MOVWF		TEMP_HIGH
			INCF		RXIN_00,F			;UPDATE THE DECIMAL RESULT REGISTER
			GOTO		HEX_TO_DEC_ASCII_10000_L	;TRY TO SUBTRACT D'10000' H'3E8' AGAIN
HEX_TO_DEC_ASCII_1000	;CAN WE SUBTRACT D'1000' H'3E8' FROM TEMP_HIGH AND TEMP_LOW??
			MOVF		TEMP_LOW,W
			MOVWF		TEMP_LOW_WORKING
			MOVF		TEMP_HIGH,W
			MOVWF		TEMP_HIGH_WORKING
HEX_TO_DEC_ASCII_1000_L	MOVLW		H'E8'				;SUBTRACT H'10' FROM TEMP_LOW
			SUBWF		TEMP_LOW_WORKING,F
			MOVLW		H'01'				;PREPARE FOR SUBTRACTION
			BTFSS		STATUS,C			;WAS THERE A BORROW?
			SUBWF		TEMP_HIGH_WORKING,F		;SUBTRACT H'01' FROM TEMP_HIGH IF WE BORROWED
			BTFSS		STATUS,C			;WAS THERE A BORROW? IF THERE WAS WE SKIP TO NEXT
			GOTO		HEX_TO_DEC_ASCII_100
			MOVLW		H'03'
			SUBWF		TEMP_HIGH_WORKING,F
			BTFSS		STATUS,C			;WAS THERE A BORROW? IF THERE WAS WE SKIP TO NEXT
			GOTO		HEX_TO_DEC_ASCII_100
			MOVF		TEMP_LOW_WORKING,W		;STORE CURRENT RESULTS
			MOVWF		TEMP_LOW
			MOVF		TEMP_HIGH_WORKING,W
			MOVWF		TEMP_HIGH
			INCF		RXIN_01,F			;UPDATE THE DECIMAL RESULT REGISTER
			GOTO		HEX_TO_DEC_ASCII_1000		;TRY TO SUBTRACT D'1000' H'3E8' AGAIN
HEX_TO_DEC_ASCII_100	;CAN WE SUBTRACT D'100' H'64' FROM TEMP_LOW??
			MOVF		TEMP_LOW,W
			MOVWF		TEMP_LOW_WORKING
			MOVF		TEMP_HIGH,W
			MOVWF		TEMP_HIGH_WORKING
HEX_TO_DEC_ASCII_100_L	MOVLW		H'64'				;SUBTRACT H'10' FROM TEMP_LOW
			SUBWF		TEMP_LOW_WORKING,F
			MOVLW		H'01'				;PREPARE FOR SUBTRACTION
			BTFSS		STATUS,C			;WAS THERE A BORROW?
			SUBWF		TEMP_HIGH_WORKING,F		;SUBTRACT H'01' FROM TEMP_HIGH IF WE BORROWED
			BTFSS		STATUS,C			;WAS THERE A BORROW? IF THERE WAS WE SKIP TO NEXT
			GOTO		HEX_TO_DEC_ASCII_10
			MOVF		TEMP_LOW_WORKING,W		;STORE CURRENT RESULTS
			MOVWF		TEMP_LOW
			MOVF		TEMP_HIGH_WORKING,W
			MOVWF		TEMP_HIGH
			INCF		RXIN_02,F			;UPDATE THE DECIMAL RESULT REGISTER
			GOTO		HEX_TO_DEC_ASCII_100_L		;TRY TO SUBTRACT D'1000' H'3E8' AGAIN
HEX_TO_DEC_ASCII_10	;CAN WE SUBTRACT D'10' H'0A' FROM TEMP_LOW??
			MOVF		TEMP_LOW,W
			MOVWF		TEMP_LOW_WORKING
			MOVF		TEMP_HIGH,W
			MOVWF		TEMP_HIGH_WORKING
HEX_TO_DEC_ASCII_10_L	MOVLW		H'0A'				;SUBTRACT H'10' FROM TEMP_LOW
			SUBWF		TEMP_LOW_WORKING,F
			BTFSS		STATUS,C			;WAS THERE A BORROW?
			GOTO		HEX_TO_DEC_ASCII_1
			MOVF		TEMP_LOW_WORKING,W		;STORE CURRENT RESULTS
			MOVWF		TEMP_LOW
			INCF		RXIN_03,F			;UPDATE THE DECIMAL RESULT REGISTER
			GOTO		HEX_TO_DEC_ASCII_10_L		;TRY TO SUBTRACT D'1000' H'3E8' AGAIN
HEX_TO_DEC_ASCII_1	;WE KNOW WE CAN DO THIS FOR SURE, JUST MOVE THE REMAINING VALUE OUT
			MOVF		TEMP_LOW,W
			MOVWF		RXIN_04

			MOVLW		H'30'				;ADD H'30' TO EACH RESULT TO MAKE THEM ASCII
			ADDWF		RXIN_00,F
			ADDWF		RXIN_01,F
			ADDWF		RXIN_02,F
			ADDWF		RXIN_03,F
			ADDWF		RXIN_04,F

			RETURN						;RETURN, RESULT IS IN RXIN_00 THROUGH RXIN_04

;==========================================================================================================================
;	HEX TO HEXADECIMAL CONVERSION (CONVERTS ONLY ONE NIBBLE AT A TIME)
;==========================================================================================================================
HEX_TO_ASCII
			MOVWF		TEMP
			MOVLW		H'0F'
			ANDWF		TEMP,F
			MOVLW		H'30'				;MOV 30h INTO W
			ADDWF		TEMP,F				;ADD W TO TEMP (ADD 30h)
			MOVLW		H'3A'				;DETERMINE IF TEMP IS ABOVE 39h
			SUBWF		TEMP,W
			BTFSS		STATUS,C
			GOTO		HEX_TO_ASCII_END		;IF IT IS NOT THEN RETURN
			MOVLW		H'07'				;IF IT IS THEN MOV 07h INTO W
			ADDWF		TEMP,F				;AND ADD W INTO TEMP TO MAKE IT A CHARACTER
HEX_TO_ASCII_END	MOVF		TEMP,W				;PUT VALUE IN W THAT WAS CALCULATED
			RETURN						;RETURN
;==========================================================================================================================
;	ASCII DECIMAL TO HEX CONVERSION (CONVERTS ONLY ONE DIGIT AT A TIME)
;==========================================================================================================================
ASCII_TO_HEX
			MOVWF		TEMP				;COPY TO WORKING REGISTER
			;FIRST CHECK IF THE NUMBER IS NOT LESS THAN 30h, STORE THE RESULT
			MOVLW		H'30'				;SUBTRACT 30h FROM THE ENTRY
			SUBWF		TEMP,F
			BTFSS		STATUS,C			;IF NO BORROW OCCURED, STATUS,C WILL BE SET
			RETLW		H'0F'				;ERROR ON CONVERT, RETURNED Fh INDICATES ERROR
			;NOW CHECK IF THE NUMBER IS MORE THAN 9, DON'T STORE THE RESULT
			MOVLW		H'F6'
			ADDWF		TEMP,W
			BTFSC		STATUS,C			;CHECK NO CARRY OCCURED, STATUS,C WILL BE CLEAR
			RETLW		H'0F'				;ERROR ON CONVERT, RETURNED Fh INDICATES ERROR
			MOVF		TEMP,W
			RETURN

;------------------------------------------------------------------------------------
;		CONVERTS THE DECIMAL DATA FROM RS232 TO HEX FORMATED DATA
;		AND VERIFIES IT HAS A VALID VALUE
;------------------------------------------------------------------------------------
RXIN_CHECK								;CHECK THE DATA AND PEPARE IT TO BE USED ON THE OUTPUTS
			MOVWF		TEMP
			MOVLW		H'30'				;SUBTRACT 30h FROM RXIN1
			SUBWF		TEMP,F				;AND STORE BACK IN RXIN1
			BTFSS		STATUS,C			;CHECK TO SEE IF VALUE IS LESS THAN 0
			BSF		TEMP,7				;SET ERROR BIT HIGH
			MOVLW		H'0A'				;MOV 0Ah INTO W REG FOR COMPARE
			SUBWF		TEMP,W				;SUBTRACT 0Ah TO COMPARE
			BTFSS		STATUS,C			;IF RXIN1 IS 0Ah OR LARGER THEN SKIP NEXT STEP
			GOTO		RXIN_CHECK_1			;GOTO RXIN_1_1 IF IT IS NOT A HEX NUMBER >9
			MOVLW		H'07'				;MOV 07h INTO W
			SUBWF		TEMP,F				;SUBTRACT W FROM RXIN1 AND STORE BACK IN RXIN1
RXIN_CHECK_1
			MOVLW		H'10'				;MOV 10h INTO W
			SUBWF		TEMP,W				;SUBTRACT 0Fh FROM RXIN1 AND STORE THE VALUE IN W
			BTFSC		STATUS,C			;CHECK TO SEE IF AN UNDERFLOW OCCURED...IF NOT THEN SKIP NEXT LINE
			BSF		TEMP,7				;SET ERROR BIT HIGH
			MOVF		TEMP,W
			RETURN						;RETURN FROM RXIN_CHECK

;==========================================================================================================================
;			RS-232 COMMANDS
;==========================================================================================================================
RS232_TX_CRLF		MOVLW		H'0A'			;SEND OUT A CARRAIGE RETURN
			CALL		RS232_TX_GO
			MOVLW		H'0D'			;SEND OUT A LINE FEED
			CALL		RS232_TX_GO
			RETURN
RS232_RX_GO							;RECEIVE DATA AND STORE
			BCF		STATUS,RP0		;BANK 0
			MOVF		RCREG,0			;MOVE RECIEVED DATA TO RXIN REGISTER
			MOVWF		RXIN
			MOVF		RXIN,0
			RETURN
RS232_RX_GO_WRITE						;RECEIVE DATA AND STORE
			BCF		STATUS,5		;BANK 0
			MOVF		RCREG,0			;MOVE RECIEVED DATA TO RXIN REGISTER
			MOVWF		RXIN
			RETURN
RS232_TX_GO							;TRANSMIT DATA FROM REGISTER
;			MOVWF		TXOUT
			BSF		STATUS,5		;BANK 1
			BSF		TXSTA,5
			BCF		STATUS,5		;BANK 0
;			MOVF		TXOUT,0			;SEND DATA OUT RS232
			MOVWF		TXREG
			BSF		STATUS,5
TM									;WAIT FOR DATA TO FINISH TRANSMITTING TO CONTINUE WITH PROGRAM
			BTFSS		TXSTA,1
			GOTO		TM
			BCF		STATUS,5			;BANK 0
			RETLW		0				;RETURN

TEXT_TABLE		MOVWF		TEXT_TABLE_L			;COPY IN THE TEXT_TABLE_L VALUE FOR LATER USE
			CLRF		TABLE_OFFSET_H			;CLEAR THE TABLE OFFSETS
			CLRF		TABLE_OFFSET_L			;CLEAR THE TABLE OFFSETS
TEXT_TABLE_R		MOVLW		HIGH TABLE_JUMP			;COPY THE HIGH TABLE ADDRESS TO PCLATH
			MOVWF		PCLATH
			CALL		TABLE_JUMP			;CALL THE TABLE TO GET A VALUE, RETURNED VALUE WILL BE IN WREG
			BCF		PCLATH,3			;PROGRAM PAGE 0 ON NEXT GOTO OR CALL
			ADDLW		0				;CHECK IF RETURNED VALUE IS ZERO (WE ADD ZERO TO WREG)
			BTFSC		STATUS,Z			;CHECK ZERO FLAG. WE USE THIS METHOD NOT TO DISTURB WREG
			RETURN
			INCF		TABLE_OFFSET_L,F		;INCF THE TABLE OFFSET FOR THE NEXT VALUE
			BTFSC		STATUS,Z			;CHECK FOR CARRY
			INCF		TABLE_OFFSET_H,F
			CALL		RS232_TX_GO			;OUTPUT VALUE IN WREG TO RS232
			GOTO		TEXT_TABLE_R			;REPEAT


;-----------------------------------------------------------------------------
;       BYTE-WRITE, write one byte to I2C (Master Mode)
;-----------------------------------------------------------------------------
;       Input   :       DATAO= data to be written
;                       ADDR    = destination address
;                       SLAVE   = device address (1010xxx0)
;       Output  :       Data written to EEPROM device
;-----------------------------------------------------------------------------
WRBYTE_START
	bsf		CHIP_OPEN,0		;SPECIFIES THAT CHIP IS OPEN
   CALL BSTART

   MOVLW B'10100000'
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_H,W
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_L,W
   MOVWF TXBUF
   CALL TX
	RETURN

WRBYTE_DATA
   MOVF DATAO,W
   MOVWF TXBUF
   CALL TX
	RETURN

WRBYTE_STOP
	BCF		CHIP_OPEN,0		;SPECIFIES THAT CHIP IS CLOSED
   CALL BSTOP

   RETURN

;-----------------------------------------------------------------------------
;       BYTE-READ, read one byte from I2C (Master Mode)
;-----------------------------------------------------------------------------
;       Input   :       ADDR    = source address
;                       SLAVE   = device address (1010xxx0)
;       Output  :       DATAI   = data read from serial EEPROM
;-----------------------------------------------------------------------------
RDBYTE
	BCF		SEND_ACK,0		;SEND ACK SIGNAL AFTER RECEIVE (FOR ONLY ONE READ)
   CALL BSTART

   MOVLW B'10100000'
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_H,W
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_L,W
   MOVWF TXBUF
   CALL TX

   CALL BSTART

   MOVLW B'10100001'
   MOVWF TXBUF
   CALL TX

   CALL RX

   CALL BSTOP

   RETURN

RDBYTE_START
	BSF		SEND_ACK,0		;DO NOT ACK SIGNAL AFTER RECEIVE (FOR MULTIPLE READS)
   CALL BSTART

   MOVLW B'10100000'	;CONTROL BYTE
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_H,W	;ADDRESS HIGH BYTE
   MOVWF TXBUF
   CALL TX

   MOVF ADDR_L,W	;ADDRESS LOW BYTE
   MOVWF TXBUF
   CALL TX

   CALL BSTART		;GENERATE START BIT

   MOVLW B'10100001'	;CONTROL BYTE
   MOVWF TXBUF
   CALL TX
   RETURN

RDBYTE_DATA
   CALL RX
   RETURN

RDBYTE_STOP
	BCF		SEND_ACK,0		; SEND ACK SIGNAL AFTER RECEIVE (FOR ONLY ONE READ)
   CALL RX
   RETURN
   CALL BSTOP		;GENERATE STOP BIT
   RETURN

;-----------------------------------------------------------------------------
;       RECEIVE eight data bits subroutine
;-----------------------------------------------------------------------------
;       Input   :       None
;       Output  :       RXBUF = 8-bit data received
;-----------------------------------------------------------------------------

RX
   CLRF DATAI
   MOVLW .8
   MOVWF COUNT
   BCF STATUS,0
RXLP
   RLF DATAI,F
   CALL BITIN
   BTFSC EEPROM,DI
   BSF DATAI,0
   DECFSZ COUNT,F
   GOTO RXLP
	btfsc	SEND_ACK,0
	bcf	EEPROM,DO       ; Set acknowledge bit = 1
	btfss	SEND_ACK,0
	bsf	EEPROM,DO
   CALL BITOUT
   RETURN
;-----------------------------------------------------------------------------
;       TRANSMIT 8 data bits subroutine
;-----------------------------------------------------------------------------
;       Input   :       TXBUF
;       Output  :       Data X'mitted to EEPROM device
;-----------------------------------------------------------------------------

TX
   MOVLW .8
   MOVWF COUNT
TXLP
   BCF EEPROM,DO
   BTFSC TXBUF,7
   BSF EEPROM,DO
   CALL BITOUT
   RLF TXBUF,F
   DECFSZ COUNT,F
   GOTO TXLP
   CALL BITIN
   RETURN

;-----------------------------------------------------------------------------
;       Single bit receive from I2C to PIC
;-----------------------------------------------------------------------------
;       Input   :       None
;       Output  :       Data bit received
;-----------------------------------------------------------------------------

BITIN
   BSF EEPROM,DI

   BSF STATUS,RP0
	BCF	TRIS_IIC,SCL
	BSF	TRIS_IIC,SDA
   BCF STATUS, RP0

   BSF PORT_IIC,SCL
   NOP
   NOP
   NOP
   NOP
   NOP
   BTFSS PORT_IIC,SDA
   BCF EEPROM,DI
   BCF PORT_IIC,SCL
   RETURN

;-----------------------------------------------------------------------------
;       Single bit data transmit from PIC to I2C
;-----------------------------------------------------------------------------
;       Input   :       EEPROM register, bit DO
;       Output  :       Bit transmitted over I2C
;			Error bits set as necessary
;-----------------------------------------------------------------------------

BITOUT
   BSF STATUS, RP0
	BCF	TRIS_IIC,SCL
	BCF	TRIS_IIC,SDA
   BCF STATUS, RP0

   BTFSS EEPROM,DO
   GOTO BITLOW
   BSF PORT_IIC,SDA
   GOTO CLK_OUT
BITLOW
   BCF PORT_IIC,SDA
CLK_OUT
   BSF PORT_IIC,SCL
   NOP
   NOP
   NOP
   NOP
   BCF PORT_IIC,SCL
   NOP
   RETURN

;-----------------------------------------------------------------------------
;       DELAY, Provide a 1.54mS delay (NOT 1.54mS ANY LONGER, DONT KNOW HOW LONG)
;-----------------------------------------------------------------------------
;       Input   :       None
;       Output  :       None
;-----------------------------------------------------------------------------

DELAY_NMS
   MOVWF DEL
OUTTER_MS
   MOVLW .110
   MOVWF SEL
INNER_MS
   NOP
   NOP
   NOP
   NOP
   NOP
   NOP
   DECFSZ SEL,F
   GOTO INNER_MS
   DECFSZ DEL,F
   GOTO OUTTER_MS
   RETURN
;-----------------------------------------------------------------------------
;       START bit generation routine
;-----------------------------------------------------------------------------
;       input   : none
;       output  : initialize bus communication
;-----------------------------------------------------------------------------

;Generate START bit (SCL is high while SDA goes from high to low transition)
;and check status of the serial clock.
BSTART
   BSF PORT_IIC,SDA
   BSF STATUS, RP0
   BCF	TRIS_IIC,SCL
   BCF	TRIS_IIC,SDA
   BCF STATUS, RP0

   BCF PORT_IIC,SCL
   NOP
   BSF PORT_IIC,SCL
   NOP
   NOP
   NOP
   NOP
   NOP
   BCF PORT_IIC,SDA
   NOP
   NOP
   NOP
   NOP
   NOP
   BCF PORT_IIC,SCL
   NOP
   NOP
   RETURN

;-----------------------------------------------------------------------------
;       STOP bit generation routine
;-----------------------------------------------------------------------------
;       Input   :       None
;       Output  :       Bus communication, STOP condition
;-----------------------------------------------------------------------------

;Generate STOP bit (SDA goes from low to high during SCL high state)
;and check bus conditions.

BSTOP
   BSF STATUS, RP0
   BCF	TRIS_IIC,SCL
   BCF	TRIS_IIC,SDA
   BCF STATUS, RP0

   BCF PORT_IIC,SDA
   NOP
   NOP
   NOP
   BSF PORT_IIC,SCL
   NOP
   NOP
   NOP
   BSF PORT_IIC,SDA
   NOP
   NOP
   BCF PORT_IIC,SCL
   NOP
   NOP
   NOP
   RETURN

;-----------------------------------------------------------------------------
;				***BEGIN PROGRAM MEMORY PAGE 1***
;-----------------------------------------------------------------------------
	ORG	H'800'		;SET ORIGIN AT PROGRAM MEMORY 0800h IN PAGE 1

TABLE_JUMP		MOVF		TEXT_TABLE_H,W			;COPY THE HIGH TABLE ADDRESS TO PCLATH
			ADDWF		TABLE_OFFSET_H,W		;TAKE CARE OF THE HIGH BYTE OF THE OFFSET
			MOVWF		PCLATH				;WRITE THE FINAL VALUE INTO PCLATH
			MOVF		TEXT_TABLE_L,W			;TEXT_TABLE_L WILL JUST BE USED FOR THE CALL LINE, SO DON'T NEED
			ADDWF		TABLE_OFFSET_L,W		;GET THE CURRENT OFFSET AND LOAD IT IN WREG
			BTFSC		STATUS,C			;IF WE OVERFLOWED, WE WILL GET A CARRY
			INCF		PCLATH,F			;IN THIS CASE, INCF PCLATH IF THE JUMP OVERFLOWS
			MOVWF		PCL
TABLE_RS232_GET_ABORT	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'O'
			RETLW		'P'
			RETLW		'E'
			RETLW		'R'
			RETLW		'A'
			RETLW		'T'
			RETLW		'I'
			RETLW		'O'
			RETLW		'N'
			RETLW		' '
			RETLW		'A'
			RETLW		'B'
			RETLW		'O'
			RETLW		'R'
			RETLW		'T'
			RETLW		'E'
			RETLW		'D'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_VERSION		RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'F'
			RETLW		'I'
			RETLW		'R'
			RETLW		'M'
			RETLW		'W'
			RETLW		'A'
			RETLW		'R'
			RETLW		'E'
			RETLW		' '
			RETLW		'R'
			RETLW		'E'
			RETLW		'V'
			RETLW		'I'
			RETLW		'S'
			RETLW		'I'
			RETLW		'O'
			RETLW		'N'
			RETLW		' '
			RETLW		'1'
			RETLW		'.'
			RETLW		'0'
			RETLW		'c'
			RETLW		' '
			RETLW		' '
			RETLW		'0'
			RETLW		'6'
			RETLW		'/'
			RETLW		'1'
			RETLW		'8'
			RETLW		'/'
			RETLW		'2'
			RETLW		'0'
			RETLW		'1'
			RETLW		'1'

			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'P'
			RETLW		'R'
			RETLW		'O'
			RETLW		'G'
			RETLW		'R'
			RETLW		'A'
			RETLW		'M'
			RETLW		' '
			RETLW		'D'
			RETLW		'E'
			RETLW		'S'
			RETLW		'I'
			RETLW		'G'
			RETLW		'N'
			RETLW		' '
			RETLW		'B'
			RETLW		'Y'
			RETLW		' '
			RETLW		'A'
			RETLW		'L'
			RETLW		'L'
			RETLW		'A'
			RETLW		'N'
			RETLW		' '
			RETLW		'D'
			RETLW		'R'
			RETLW		'A'
			RETLW		'S'
			RETLW		'S'
			RETLW		'A'
			RETLW		'L'

			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_MENU		RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'W'
			RETLW		'7'
			RETLW		'Y'
			RETLW		'H'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'A'
			RETLW		'C'
			RETLW		'C'
			RETLW		'E'
			RETLW		'S'
			RETLW		'S'
			RETLW		' '
			RETLW		'C'
			RETLW		'O'
			RETLW		'N'
			RETLW		'T'
			RETLW		'R'
			RETLW		'O'
			RETLW		'L'
			RETLW		'L'
			RETLW		'E'
			RETLW		'R'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'a'
			RETLW		' '
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'b'
			RETLW		' '
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		' '
			RETLW		'L'
			RETLW		'A'
			RETLW		'S'
			RETLW		'T'
			RETLW		' '
			RETLW		'S'
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'N'
			RETLW		'E'
			RETLW		'D'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'd'
			RETLW		' '
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'D'
			RETLW		'E'
			RETLW		'L'
			RETLW		'E'
			RETLW		'T'
			RETLW		'E'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'l'
			RETLW		'f'
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'L'
			RETLW		'I'
			RETLW		'S'
			RETLW		'T'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		'S'
			RETLW		' '
			RETLW		'B'
			RETLW		'Y'
			RETLW		' '
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		' '
			RETLW		'N'
			RETLW		'U'
			RETLW		'M'
			RETLW		'B'
			RETLW		'E'
			RETLW		'R'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

;			RETLW		'm'
;			RETLW		'e'
;			RETLW		' '
;			RETLW		'='
;			RETLW		' '
;			RETLW		'M'
;			RETLW		'E'
;			RETLW		'M'
;			RETLW		'O'
;			RETLW		'R'
;			RETLW		'Y'
;			RETLW		' '
;			RETLW		'E'
;			RETLW		'R'
;			RETLW		'A'
;			RETLW		'S'
;			RETLW		'E'
;			RETLW		' '
;			RETLW		'('
;			RETLW		'A'
;			RETLW		'L'
;			RETLW		'L'
;			RETLW		')'
;			RETLW		H'0D'	;CARRAIGE RETURN
;			RETLW		H'0A'	;LINE FEED

;			RETLW		'm'
;			RETLW		'f'
;			RETLW		' '
;			RETLW		'='
;			RETLW		' '
;			RETLW		'M'
;			RETLW		'E'
;			RETLW		'M'
;			RETLW		'O'
;			RETLW		'R'
;			RETLW		'Y'
;			RETLW		' '
;			RETLW		'R'
;			RETLW		'E'
;			RETLW		'A'
;			RETLW		'D'
;			RETLW		' '
;			RETLW		'F'
;			RETLW		'A'
;			RETLW		'T'
;			RETLW		' '
;			RETLW		'T'
;			RETLW		'A'
;			RETLW		'B'
;			RETLW		'L'
;			RETLW		'E'
;			RETLW		H'0D'	;CARRAIGE RETURN
;			RETLW		H'0A'	;LINE FEED

;			RETLW		'm'
;			RETLW		'n'
;			RETLW		' '
;			RETLW		'='
;			RETLW		' '
;			RETLW		'M'
;			RETLW		'E'
;			RETLW		'M'
;			RETLW		'O'
;			RETLW		'R'
;			RETLW		'Y'
;			RETLW		' '
;			RETLW		'R'
;			RETLW		'E'
;			RETLW		'A'
;			RETLW		'D'
;			RETLW		H'0D'	;CARRAIGE RETURN
;			RETLW		H'0A'	;LINE FEED

			RETLW		'm'
			RETLW		'r'
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'M'
			RETLW		'E'
			RETLW		'M'
			RETLW		'O'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'R'
			RETLW		'E'
			RETLW		'S'
			RETLW		'E'
			RETLW		'T'
			RETLW		' '
			RETLW		'('
			RETLW		'F'
			RETLW		'A'
			RETLW		'T'
			RETLW		' '
			RETLW		'O'
			RETLW		'N'
			RETLW		'L'
			RETLW		'Y'
			RETLW		')'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

;			RETLW		'm'
;			RETLW		't'
;			RETLW		' '
;			RETLW		'='
;			RETLW		' '
;			RETLW		'M'
;			RETLW		'E'
;			RETLW		'M'
;			RETLW		'O'
;			RETLW		'R'
;			RETLW		'Y'
;			RETLW		' '
;			RETLW		'F'
;			RETLW		'I'
;			RETLW		'L'
;			RETLW		'L'
;			RETLW		' '
;			RETLW		'('
;			RETLW		'F'
;			RETLW		'A'
;			RETLW		'T'
;			RETLW		' '
;			RETLW		'O'
;			RETLW		'N'
;			RETLW		'L'
;			RETLW		'Y'
;			RETLW		')'
;			RETLW		H'0D'	;CARRAIGE RETURN
;			RETLW		H'0A'	;LINE FEED

			RETLW		's'
			RETLW		' '
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'S'
			RETLW		'E'
			RETLW		'A'
			RETLW		'R'
			RETLW		'C'
			RETLW		'H'
			RETLW		' '
			RETLW		'F'
			RETLW		'O'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'v'
			RETLW		' '
			RETLW		' '
			RETLW		'='
			RETLW		' '
			RETLW		'V'
			RETLW		'E'
			RETLW		'R'
			RETLW		'S'
			RETLW		'I'
			RETLW		'O'
			RETLW		'N'
			RETLW		' '
			RETLW		'I'
			RETLW		'N'
			RETLW		'F'
			RETLW		'O'
			RETLW		'R'
			RETLW		'M'
			RETLW		'A'
			RETLW		'T'
			RETLW		'I'
			RETLW		'O'
			RETLW		'N'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		0
TABLE_CARD_ADD_SITEID	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'I'
			RETLW		'N'
			RETLW		'G'
			RETLW		' '
			RETLW		'N'
			RETLW		'E'
			RETLW		'W'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'('
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'C'
			RETLW		'E'
			RETLW		'L'
			RETLW		'S'
			RETLW		')'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'S'
			RETLW		'I'
			RETLW		'T'
			RETLW		'E'
			RETLW		' '
			RETLW		'C'
			RETLW		'O'
			RETLW		'D'
			RETLW		'E'
			RETLW		' '
			RETLW		'('
			RETLW		'0'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'2'
			RETLW		'5'
			RETLW		'5'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_CARD_SEARCH_SITEID
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'S'
			RETLW		'E'
			RETLW		'A'
			RETLW		'R'
			RETLW		'C'
			RETLW		'H'
			RETLW		' '
			RETLW		'('
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'C'
			RETLW		'E'
			RETLW		'L'
			RETLW		'S'
			RETLW		')'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'S'
			RETLW		'I'
			RETLW		'T'
			RETLW		'E'
			RETLW		' '
			RETLW		'C'
			RETLW		'O'
			RETLW		'D'
			RETLW		'E'
			RETLW		' '
			RETLW		'('
			RETLW		'0'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'2'
			RETLW		'5'
			RETLW		'5'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_CARD_ADDSCAN	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'I'
			RETLW		'N'
			RETLW		'G'
			RETLW		' '
			RETLW		'N'
			RETLW		'E'
			RETLW		'W'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'F'
			RETLW		'R'
			RETLW		'O'
			RETLW		'M'
			RETLW		' '
			RETLW		'L'
			RETLW		'A'
			RETLW		'S'
			RETLW		'T'
			RETLW		' '
			RETLW		'S'
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'N'
			RETLW		'E'
			RETLW		'D'
			RETLW		' '
			RETLW		'('
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'C'
			RETLW		'E'
			RETLW		'L'
			RETLW		'S'
			RETLW		')'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		'I'
			RETLW		'D'
			RETLW		'='
			RETLW		0
TABLE_CARD_ADD_CARDID	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'N'
			RETLW		'U'
			RETLW		'M'
			RETLW		'B'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'('
			RETLW		'0'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'6'
			RETLW		'5'
			RETLW		'5'
			RETLW		'3'
			RETLW		'5'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_CARD_ADD_NAME	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'F'
			RETLW		'U'
			RETLW		'L'
			RETLW		'L'
			RETLW		' '
			RETLW		'N'
			RETLW		'A'
			RETLW		'M'
			RETLW		'E'
			RETLW		' '
			RETLW		'('
			RETLW		'U'
			RETLW		'P'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'2'
			RETLW		'7'
			RETLW		' '
			RETLW		'C'
			RETLW		'H'
			RETLW		'A'
			RETLW		'R'
			RETLW		'A'
			RETLW		'C'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		'S'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_CARD_ADD_DONE	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'E'
			RETLW		'D'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'S'
			RETLW		'Y'
			RETLW		'S'
			RETLW		'T'
			RETLW		'E'
			RETLW		'M'
			RETLW		','
			RETLW		' '
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		'I'
			RETLW		'D'
			RETLW		'='
			RETLW		0
TABLE_CARD_LIST_FILEID	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'L'
			RETLW		'I'
			RETLW		'S'
			RETLW		'T'
			RETLW		' '
			RETLW		'B'
			RETLW		'Y'
			RETLW		' '
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		' '
			RETLW		'N'
			RETLW		'U'
			RETLW		'M'
			RETLW		'B'
			RETLW		'E'
			RETLW		'R'
			RETLW		':'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED

			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		'I'
			RETLW		'D'
			RETLW		' '
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		'I'
			RETLW		'D'
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		'N'
			RETLW		'A'
			RETLW		'M'
			RETLW		'E'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_CARD_ERROR_PARSE	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'I'
			RETLW		'N'
			RETLW		'V'
			RETLW		'A'
			RETLW		'L'
			RETLW		'I'
			RETLW		'D'
			RETLW		' '
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'R'
			RETLW		'Y'
			RETLW		','
			RETLW		' '
			RETLW		'T'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'A'
			RETLW		'G'
			RETLW		'A'
			RETLW		'I'
			RETLW		'N'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_CARD_SEARCH_SUCCESS
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'F'
			RETLW		'O'
			RETLW		'U'
			RETLW		'N'
			RETLW		'D'
			RETLW		'!'
			RETLW		' '
			RETLW		'S'
			RETLW		'T'
			RETLW		'A'
			RETLW		'T'
			RETLW		'U'
			RETLW		'S'
			RETLW		'='
			RETLW		0
TABLE_CARD_SEARCH_SUCCESS_2
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		'I'
			RETLW		'D'
			RETLW		'='
			RETLW		0
TABLE_CARD_SEARCH_SUCCESS_3
			RETLW		' '
			RETLW		'N'
			RETLW		'A'
			RETLW		'M'
			RETLW		'E'
			RETLW		'='
			RETLW		0
TABLE_CARD_SEARCH_FAIL	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'N'
			RETLW		'O'
			RETLW		'T'
			RETLW		' '
			RETLW		'F'
			RETLW		'O'
			RETLW		'U'
			RETLW		'N'
			RETLW		'D'
			RETLW		'!'
			RETLW		0
TABLE_CARD_ADD_DUPLICATE
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'H'
			RETLW		'A'
			RETLW		'S'
			RETLW		' '
			RETLW		'A'
			RETLW		'L'
			RETLW		'R'
			RETLW		'E'
			RETLW		'A'
			RETLW		'D'
			RETLW		'Y'
			RETLW		' '
			RETLW		'B'
			RETLW		'E'
			RETLW		'E'
			RETLW		'N'
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'E'
			RETLW		'D'
			RETLW		'!'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_CARD_ADD_NOMEM	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'N'
			RETLW		'O'
			RETLW		' '
			RETLW		'M'
			RETLW		'E'
			RETLW		'M'
			RETLW		'O'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'T'
			RETLW		'O'
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		'!'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_MEMORY_ERASE	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'M'
			RETLW		'E'
			RETLW		'M'
			RETLW		'O'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'E'
			RETLW		'R'
			RETLW		'A'
			RETLW		'S'
			RETLW		'E'
			RETLW		'D'
			RETLW		'!'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_MEMORY_FILL	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'M'
			RETLW		'E'
			RETLW		'M'
			RETLW		'O'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'L'
			RETLW		'E'
			RETLW		'D'
			RETLW		'!'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_CARD_DELETE_FILEID
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'D'
			RETLW		'E'
			RETLW		'L'
			RETLW		'E'
			RETLW		'T'
			RETLW		'I'
			RETLW		'N'
			RETLW		'G'
			RETLW		' '
			RETLW		'E'
			RETLW		'X'
			RETLW		'I'
			RETLW		'S'
			RETLW		'T'
			RETLW		'I'
			RETLW		'N'
			RETLW		'G'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'('
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'C'
			RETLW		'A'
			RETLW		'N'
			RETLW		'C'
			RETLW		'E'
			RETLW		'L'
			RETLW		'S'
			RETLW		')'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'T'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'F'
			RETLW		'I'
			RETLW		'L'
			RETLW		'E'
			RETLW		'I'
			RETLW		'D'
			RETLW		':'
			RETLW		0
TABLE_CARD_DELETE_DONE	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'R'
			RETLW		'D'
			RETLW		' '
			RETLW		'D'
			RETLW		'E'
			RETLW		'L'
			RETLW		'E'
			RETLW		'T'
			RETLW		'E'
			RETLW		'D'
			RETLW		'!'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_MEMORY_READ_S	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'S'
			RETLW		'T'
			RETLW		'A'
			RETLW		'R'
			RETLW		'T'
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'R'
			RETLW		'E'
			RETLW		'S'
			RETLW		'S'
			RETLW		' '
			RETLW		'('
			RETLW		'e'
			RETLW		'x'
			RETLW		'.'
			RETLW		' '
			RETLW		'0'
			RETLW		'0'
			RETLW		'1'
			RETLW		'F'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_MEMORY_READ_E	RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'E'
			RETLW		'N'
			RETLW		'D'
			RETLW		' '
			RETLW		'A'
			RETLW		'D'
			RETLW		'D'
			RETLW		'R'
			RETLW		'E'
			RETLW		'S'
			RETLW		'S'
			RETLW		' '
			RETLW		'('
			RETLW		'e'
			RETLW		'x'
			RETLW		'.'
			RETLW		' '
			RETLW		'1'
			RETLW		'F'
			RETLW		'F'
			RETLW		'F'
			RETLW		')'
			RETLW		':'
			RETLW		0
TABLE_POR	RETLW		'P'
			RETLW		'O'
			RETLW		'W'
			RETLW		'E'
			RETLW		'R'
			RETLW		' '
			RETLW		'O'
			RETLW		'N'
			RETLW		' '
			RETLW		'R'
			RETLW		'E'
			RETLW		'S'
			RETLW		'E'
			RETLW		'T'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		0
TABLE_LF	RETLW		'M'
			RETLW		'E'
			RETLW		'M'
			RETLW		'O'
			RETLW		'R'
			RETLW		'Y'
			RETLW		' '
			RETLW		'S'
			RETLW		'U'
			RETLW		'M'
			RETLW		'M'
			RETLW		'A'
			RETLW		'R'
			RETLW		'Y'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'C'
			RETLW		'A'
			RETLW		'P'
			RETLW		'A'
			RETLW		'C'
			RETLW		'I'
			RETLW		'T'
			RETLW		'Y'
			RETLW		':'
			RETLW		' '
			RETLW		'2'
			RETLW		'5'
			RETLW		'5'
			RETLW		H'0D'	;CARRAIGE RETURN
			RETLW		H'0A'	;LINE FEED
			RETLW		'U'
			RETLW		'S'
			RETLW		'E'
			RETLW		'D'
			RETLW		':'
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		' '
			RETLW		0
	END
